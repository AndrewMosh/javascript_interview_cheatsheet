## Способы создания объекта

1. Литеральная нотация:

```
var obj = {}; // пустой объект
var person = {
  name: "John",
  age: 30,
  location: "New York"
};
```

2. Функция-конструктор:

```
function Person(name, age, location) {
  this.name = name;
  this.age = age;
  this.location = location;
}

var john = new Person("John", 30, "New York");
```

3. Object.create():

```
var personProto = {
  sayHello: function() {
    console.log("Hello!");
  }
};

var john = Object.create(personProto);
john.name = "John";
john.age = 30;
john.location = "New York";
```

4. Class (введена в ECMAScript 2015):

```
class Person {
  constructor(name, age, location) {
    this.name = name;
    this.age = age;
    this.location = location;
  }
}

var john = new Person("John", 30, "New York");
```

## Цепочка прототипов

Прототипное наследование в JavaScript основано на концепции цепочки прототипов, или прототипной цепочки. Каждый объект в JavaScript имеет свойство прототипа (**proto**), которое ссылается на другой объект, называемый прототипом.

Если свойство не найдено в самом объекте, JavaScript будет искать его в прототипе, а затем в прототипе прототипа, и так далее, пока не будет найдено свойство или прототип станет равным null. Эта последовательность поиска свойств называется прототипной цепочкой.

Прототипное наследование позволяет объекту наследовать свойства своего прототипа. Если свойство не найдено в самом объекте, оно будет искаться в его прототипе и так далее. Это позволяет создавать иерархии объектов, где более специфичные объекты наследуют свойства от более общих объектов.

Например, если у объекта `obj` нет свойства `x`, JavaScript будет искать его в `obj.__proto__`, затем в `obj.__proto__.__proto__` и так далее, пока не будет найдено либо встретится null.

## Разница между `call`, `apply` и `bind`

В JavaScript, методы `call`, `apply` и `bind` используются для установки контекста выполнения функции и передачи аргументов.

Метод `call` вызывает функцию с заданным контекстом и передает аргументы в виде отдельных значений. Синтаксис: `function.call(context, arg1, arg2, ...)`.

Метод `apply` также вызывает функцию с заданным контекстом, но передает аргументы в виде массива. Синтаксис: `function.apply(context, [arg1, arg2, ...])`.

Метод `bind` создает новую функцию, привязывая ее к определенному контексту выполнения и, при необходимости, предоставляя некоторые аргументы. Этот метод не вызывает функцию немедленно, а возвращает новую функцию, которую можно вызвать позже. Синтаксис: `function.bind(context, arg1, arg2, ...)`. Вызов новой функции `bind` с переданными аргументами вызовет исходную функцию с указанным контекстом.

Основное отличие между `call`, `apply` и `bind` заключается в способе передачи аргументов. `call` передает аргументы в виде отдельных значений, `apply` передает аргументы в виде массива, а `bind` создает новую функцию с предустановленными аргументами.

## Json и основные операции с ним

JSON (JavaScript Object Notation) - это формат обмена данными, основанный на языке JavaScript. Он используется для передачи структурированных данных между клиентским и серверным приложениями. JSON представляет данные в удобном для чтения и записи формате и легко интерпретируется как людьми, так и компьютерами.

Основные операции, которые можно выполнять с JSON, включают следующее:

1. Создание JSON-объекта: Можно создавать JSON-объекты, используя фигурные скобки {}. Внутри объекта можно определить пары "ключ-значение".

2. Запись данных в JSON: Значения могут быть строками, числами, логическими значениями (true/false), null или другими JSON-объектами или массивами.

3. Чтение данных из JSON: Можно обратиться к значениям в JSON с помощью их ключей и получить доступ к содержимому.

4. Обновление данных в JSON: Можно обновлять значения, присваивая новые значения ключам.

5. Удаление данных из JSON: Ключи и их значения могут быть удалены из JSON-объекта.

6. Парсинг и сериализация: JSON может быть преобразован из строки в формате JSON в структуру данных и обратно с помощью парсинга и сериализации.

JSON является широко распространенным форматом данных, который часто используется в веб-разработке и API. Он легко читается компьютерами и людьми, и может быть использован практически на любом языке программирования.

## Для чего нужен метод slice

Метод `slice()` в JavaScript используется для создания нового массива, содержащего копию части исходного массива. Он позволяет выбирать элементы из исходного массива, начиная с указанного индекса и до определенного индекса (не включая его).

Синтаксис метода `slice()` выглядит следующим образом:

```javascript
array.slice(start, end);
```

Где:

- `start` - необязательный параметр, определяющий индекс, с которого начинается выбор элементов. Если `start` не указан, метод начинает выбор с индекса 0.
- `end` - необязательный параметр, указывающий индекс, до которого выбираются элементы. Метод выбирает элементы до этого индекса, но не включая его. Если `end` не указан, метод выбирает все элементы от `start` до конца массива.

Метод `slice()` возвращает новый массив, содержащий выбранные элементы. Исходный массив при этом не изменяется.

Пример использования метода `slice()`:

```javascript
let fruits = ["apple", "banana", "orange", "grapefruit", "kiwi"];

let citrus = fruits.slice(2, 4);
console.log(citrus); // ['orange', 'grapefruit']

let lastTwo = fruits.slice(-2);
console.log(lastTwo); // ['grapefruit', 'kiwi']

let copy = fruits.slice();
console.log(copy); // ['apple', 'banana', 'orange', 'grapefruit', 'kiwi']
```

В первом примере метод `slice(2, 4)` выбирает элементы с индексами 2 и 3 из массива `fruits` и возвращает новый массив `['orange', 'grapefruit']`.

Во втором примере метод `slice(-2)` выбирает последние два элемента из массива `fruits` и возвращает новый массив `['grapefruit', 'kiwi']`.

В последнем примере метод `slice()` без аргументов создает копию исходного массива `fruits` и возвращает новый массив `['apple', 'banana', 'orange', 'grapefruit', 'kiwi']`.

## Для чего нужен метод splice

Метод `splice()` в JavaScript используется для изменения содержимого массива путем удаления, замены или добавления элементов. Он может принимать несколько аргументов, включая индекс начала изменения, количество элементов для удаления и элементы, которые нужно добавить.

Например, если мы хотим удалить элементы из массива, мы можем использовать `splice()` следующим образом:

```javascript
const fruits = ["яблоко", "груша", "банан", "апельсин"];

// Удаляем один элемент начиная с индекса 1
fruits.splice(1, 1);
// Результат: ['яблоко', 'банан', 'апельсин']

// Удаляем два элемента начиная с индекса 0 и заменяем их другими элементами
fruits.splice(0, 2, "манго", "киви");
// Результат: ['манго', 'киви', 'банан', 'апельсин']
```

Таким образом, метод `splice()` позволяет нам гибко изменять содержимое массива, добавлять новые элементы и удалять существующие.

## Разница между `slice()` и `splice()`

Методы `slice()` и `splice()` в JavaScript имеют разные цели и функциональность.

Метод `slice()` используется для создания нового массива, который будет содержать выбранные элементы из исходного массива. Он принимает два аргумента: начальный индекс и конечный индекс (не включая сам элемент с указанным конечным индексом). `slice()` возвращает новый массив, содержащий выбранные элементы, исходный массив остается неизменным.

Пример использования `slice()`:

```javascript
const fruits = ["яблоко", "груша", "банан", "апельсин"];

const selectedFruits = fruits.slice(1, 3);
// Результат: ['груша', 'банан']
```

Метод `splice()`, напротив, изменяет исходный массив, позволяя удалять, заменять или добавлять элементы. Он принимает несколько аргументов, включая индекс начала изменений, количество элементов для удаления, а также элементы, которые нужно добавить в массив. `splice()` возвращает массив удаленных элементов или пустой массив (если ничего не было удалено).

Пример использования `splice()`:

```javascript
const fruits = ["яблоко", "груша", "банан", "апельсин"];

fruits.splice(1, 2);
// Результат: ['яблоко', 'апельсин']

fruits.splice(1, 0, "манго", "киви");
// Результат: ['яблоко', 'манго', 'киви', 'апельсин']
```

Таким образом, основное отличие между `slice()` и `splice()` заключается в том, что `slice()` создает новый массив, содержащий выбранные элементы, не изменяя исходный массив, а `splice()` изменяет исходный массив путем удаления, замены или добавления элементов.

## Как сравнить Object и Map

Объекты (Objects) и карты (Maps) являются структурами данных в JavaScript и используются для хранения пар ключ-значение. Однако у них есть некоторые различия в функциональности и использовании.

Объекты в JavaScript являются коллекциями свойств, где каждое свойство имеет имя (ключ) и соответствующее значение. Ключи в объектах являются строками или символами. Объекты поддерживают доступ к значениям по ключу, добавление и удаление свойств, итерацию по свойствам и прочие операции. Однако у объектов также есть прототипы и методы, которые позволяют наследовать и расширять свойства и функциональность объектов.

Map, с другой стороны, является коллекцией, где значения хранятся в виде пар ключ-значение. Ключи в Map могут быть любого типа данных, включая объекты и функции. Map поддерживает операции добавления, удаления и обновления пар ключ-значение, а также получение значения по ключу. Он также предоставляет методы для итерации по парам ключ-значение и общую информацию о размере коллекции.

Основная разница между объектами и картами заключается в том, что объекты лучше подходят для создания и управления свойствами с определенной структурой, тогда как карты обеспечивают более гибкую структуру данных и позволяют использовать любой тип данных в качестве ключа. Кроме того, карты имеют лучшую производительность в случаях, когда требуется частое добавление и удаление пар ключ-значение.

## Разница между операторами '==' и '==='

Оператор "==" используется для сравнения значений двух операндов и возвращает true, если значения равны. Однако, при использовании оператора "==" не происходит проверка на тип данных операндов.

Оператор "===" (тройное равенство) используется для строгого сравнения значений и типов данных двух операндов. Он возвращает true, только если значения и типы данных операндов полностью совпадают.

Например:

1 == "1" возвращает true, так как значения равны, несмотря на разные типы данных (число и строка).

1 === "1" возвращает false, так как значения отличаются и типы данных тоже отличны (число и строка).

## Лямбда функции и стрелочные функции

Лямбда-функции или стрелочные функции в JavaScript представляют собой сокращенный синтаксис для создания функций. Они были добавлены в стандарт ECMAScript 6 (ES6) и позволяют определить функции более компактно и кратко.

Синтаксис лямбда-функции выглядит следующим образом:

(parameter1, parameter2, ..., parameterN) => {
// код функции
}

Этот синтаксис позволяет передавать параметры функции в скобках и описывать тело функции после стрелки (=>). Если тело функции состоит из единственного выражения, то оно может быть написано без фигурных скобок. В этом случае значение этого выражения автоматически станет возвращаемым значением функции.

Примеры использования лямбда-функций:

// Обычная функция
function multiply(a, b) {
return a \* b;
}

// Лямбда-функция
const multiply = (a, b) => a \* b;

// Вызов функции
console.log(multiply(2, 3)); // Выведет 6

Лямбда-функции очень удобны в тех случаях, когда требуется использовать функции как аргументы в других функциях (например, методы массивов, такие как map, filter, reduce и т.д.), либо для определения кратких, однострочных функций.

## Что такое функция первого класса в JavaScript?

Функция первого класса в JavaScript - это функция, которая может быть присвоена переменной, передана как аргумент в другую функцию и возвращена из функции в качестве результата. В JavaScript функции являются объектами и могут быть использованы также, как и другие типы данных, такие как строки или числа. Это означает, что функции могут быть сохранены в переменных, использованы в качестве аргументов других функций и возвращены из функций. Функции первого класса играют важную роль в функциональном программировании и позволяют использовать функции в качестве модулей, создавать замыкания и применять другие функциональные парадигмы программирования.

## Функции первого порядка

функция, которая может быть присвоена переменной, передана как аргумент в другую функцию или возвращена как результат другой функции. Такие функции могут быть использованы как любые другие значения в языке программирования.

Вот пример первоклассной функции в JavaScript:

```javascript
function sayHello(name) {
  console.log("Привет, " + name + "!");
}

var greeting = sayHello; // присвоение функции переменной
greeting("Максим"); // вызов функции через переменную
```

В данном примере функция `sayHello` присваивается переменной `greeting` и далее вызывается через эту переменную. Это один из примеров использования первоклассных функций в JavaScript.

## Что такое функция высшего порядка в JavaScript?

Функция высшего порядка (higher order function) в JavaScript - это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию в качестве результата. Это особое свойство языка, которое позволяет работать с функциями как с данными и использовать их в различных сценариях.

Пример функции высшего порядка в JavaScript:

```javascript
function multiplyBy(factor) {
  return function (number) {
    return number * factor;
  };
}

var multiplyByTwo = multiplyBy(2);
var multiplyByThree = multiplyBy(3);

console.log(multiplyByTwo(4)); // Вывод: 8
console.log(multiplyByThree(4)); // Вывод: 12
```

В этом примере функция `multiplyBy` принимает фактор и возвращает анонимную функцию, которая умножает число на данный фактор. Затем функции `multiplyByTwo` и `multiplyByThree` используются для умножения чисел на 2 и 3 соответственно.

Функции высшего порядка являются мощным инструментом в JavaScript и могут быть использованы для создания более гибкого и абстрактного кода.

## Унарная функция

Унарная функция (unary function) в JavaScript - это функция, которая принимает только один аргумент. Она обрабатывает этот аргумент и возвращает результат. Вот пример унарной функции на русском языке:

```javascript
// Унарная функция, преобразующая число в его квадрат
function квадрат(число) {
  return число * число;
}

// Вызов унарной функции
let число = 5;
let квадратЧисла = квадрат(число);
console.log(квадратЧисла); // Выведет 25
```

## Что такое каррирование в JavaScript?

Каррирование (currying) - это техника функционального программирования, которая позволяет превратить функцию с несколькими аргументами в последовательность функций, каждая из которых принимает только один аргумент.

Вот пример каррированной функции на русском языке, которая складывает два числа:

```javascript
// Каррированная функция, складывающая два числа
function сложить(a) {
  return function (b) {
    return a + b;
  };
}

// Вызов каррированной функции
let результат = сложить(2)(3);
console.log(результат); // Выведет 5
```

В этом примере `сложить(2)` возвращает функцию, которая принимает один аргумент `b` и возвращает сумму `a + b`. Затем `сложить(2)(3)` принимает второй аргумент `3` и возвращает результат сложения `2 + 3`.

## Что такое чистая функция в JavaScript?

Чистая функция (pure function) - это функция, которая всегда возвращает одинаковый результат при одинаковых входных данных и не имеет побочных эффектов. Она не изменяет состояние программы или какие-либо внешние переменные.

Вот пример чистой функции на русском языке, которая складывает два числа:

```javascript
// Чистая функция, складывающая два числа
function сложить(a, b) {
  return a + b;
}

// Вызов чистой функции
let результат = сложить(2, 3);
console.log(результат); // Выведет 5
```

В этом примере функция `сложить` всегда возвращает одинаковый результат для одних и тех же входных данных `a` и `b`, и она не влияет на состояние программы или внешние переменные.

## Какова цель ключевого слова "let" в JavaScript?

В JavaScript ключевое слово "let" используется для объявления блочной переменной, которая имеет область видимости ограниченную блоком кода, в котором она объявлена. Это отличается от ключевого слова "var", которое имеет функциональную область видимости.

Вот пример использования ключевого слова "let" на русском языке:

```javascript
function примерФункции() {
  if (условие) {
    let переменная = "Значение переменной";
    console.log(переменная); // Выведет "Значение переменной"
  }

  console.log(переменная); // Вызовет ошибку ReferenceError: переменная is not defined
}

примерФункции();
```

В этом примере переменная "переменная" объявлена с помощью ключевого слова "let" внутри блока кода условия. Она доступна только внутри этого блока, и обращение к ней за пределами блока вызовет ошибку.

## В чем разница между let и var в JavaScript?

В JavaScript существуют два ключевых слова для объявления переменных: `let` и `var`. Вот основные различия между ними:

1. Область видимости (scope):

   - Переменные, объявленные с помощью `var`, имеют функциональную область видимости. Это означает, что они доступны внутри функции, в которой они объявлены, независимо от блока кода.
   - Переменные, объявленные с помощью `let`, имеют блочную область видимости. Они доступны только в пределах блока кода, в котором они объявлены.

2. Поднятие (hoisting):

   - Переменные, объявленные с помощью `var`, поднимаются (hoisting) вверх области видимости. Это означает, что их можно использовать до того, как они были объявлены в коде.
   - Переменные, объявленные с помощью `let`, не поднимаются. Они существуют только после того, как они были объявлены в коде.

3. Повторное объявление:
   - Переменные, объявленные с помощью `var`, могут быть повторно объявлены в той же области видимости без вызова ошибки. Новое значение будет присвоено переменной.
   - Переменные, объявленные с помощью `let`, не могут быть повторно объявлены в той же области видимости. Попытка повторного объявления вызовет ошибку.

Вот пример, демонстрирующий разницу между `let` и `var` на русском языке:

```javascript
function примерФункции() {
  if (true) {
    var переменнаяVar = "Значение var";
    let переменнаяLet = "Значение let";
  }

  console.log(переменнаяVar); // Выведет "Значение var"
  console.log(переменнаяLet); // Вызовет ошибку ReferenceError: переменнаяLet is not defined
}

примерФункции();
```

В этом примере переменная `переменнаяVar`, объявленная с помощью `var`, доступна за пределами блока кода условия. Однако переменная `переменнаяLet`, объявленная с помощью `let`, не доступна за пределами блока и вызовет ошибку.

## Как переопределить переменные в блоке switch без ошибки в JavaScript?

В JavaScript, переменные внутри блока switch могут быть переопределены без ошибки, так как блок switch создает свою собственную область видимости для каждого случая (case). Это позволяет использовать одно и то же имя переменной в разных случаях без конфликтов.

Пример:

```javascript
let option = 2;
switch (option) {
  case 1:
    let message = "Первый вариант";
    console.log(message);
    break;
  case 2:
    let message = "Второй вариант"; // Нет ошибки, так как это отдельная область видимости
    console.log(message);
    break;
  default:
    let message = "Другой вариант";
    console.log(message);
}
```

В этом примере каждый блок case имеет свою собственную область видимости для переменной `message`, поэтому нет ошибок при переопределении переменной внутри блока switch.

## Что такое "Temporal Dead Zone" в JavaScript?

"Temporal Dead Zone" (временная мертвая зона) в JavaScript - это период существования переменной, когда она уже была объявлена с использованием ключевых слов `let` или `const`, но еще не может быть использована до тех пор, пока не будет до нее достигнут код выполнения. В этот период попытка доступа к переменной приведет к ошибке.

Это связано с тем, что переменные, объявленные с использованием `let` и `const`, имеют блочную область видимости и не подвергаются "всплытию" (hoisting) в начало своего блока. Они существуют только после объявления и до того момента, как выполнение программы достигнет строки, на которой они были объявлены.

Пример:

```javascript
console.log(name); // Будет ошибка временной мертвой зоны
let name = "Alice";
```

В этом примере будет ошибка "ReferenceError", потому что переменная `name` уже объявлена, но на момент вывода она все еще находится во временной мертвой зоне, и к ней нельзя обратиться до фактического объявления.

## Что такое IIFE (Immediately Invoked Function Expression) в JavaScript?

IIFE (Immediately Invoked Function Expression) в JavaScript - это паттерн, при котором функция определяется и немедленно вызывается (выполняется) в том же месте, где она была объявлена. Этот подход позволяет создать локальную область видимости для изолирования переменных и кода, исключая возможные конфликты имён с другими частями программы.

Пример:

```javascript
(function () {
  var message = "Привет из IIFE!";
  console.log(message);
})(); // Функция вызывается сразу после объявления

// Нельзя обратиться к переменной message вне IIFE, так как она находится в её области видимости
console.log(message); // Это вызовет ошибку
```

Здесь анонимная функция определена внутри круглых скобок `(function() {...})` и сразу же вызывается, заключив `()` в конце. Это создает свою область видимости, в которой можно безопасно определять переменные, не затрагивая глобальное пространство имён.

## Как декодировать или закодировать URL в JavaScript?

В JavaScript для декодирования (преобразования из закодированного вида в читаемый) или кодирования (преобразования из читаемого вида в закодированный) URL используются методы `decodeURI()`, `encodeURI()`, `decodeURIComponent()` и `encodeURIComponent()`.

### Декодирование:

- `decodeURI()` используется для декодирования всего URL.
- `decodeURIComponent()` применяется для декодирования компонентов URL, таких как параметры.

Пример декодирования:

```javascript
let encodedURL =
  "https%3A%2F%2Fexample.com%2F%3Fq%3D%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80";
let decodedURL = decodeURIComponent(encodedURL);
console.log(decodedURL);
```

### Кодирование:

- `encodeURI()` используется для кодирования всего URL.
- `encodeURIComponent()` применяется для кодирования компонентов URL, чтобы делать их безопасными для передачи.

Пример кодирования:

```javascript
let url = "https://example.com/?q=пример";
let encodedURL = encodeURI(url);
console.log(encodedURL);
```

При использовании `encodeURIComponent()`:

```javascript
let query = "пример запроса";
let encodedQuery = encodeURIComponent(query);
console.log(encodedQuery);
```

Важно понимать разницу между этими методами и выбирать правильный в зависимости от контекста.

## Что такое мемоизация (memoization) в JavaScript?

Мемоизация (memoization) в JavaScript - это оптимизационная техника, которая заключается в сохранении результатов выполнения дорогостоящих функций, чтобы избежать повторных вычислений при одних и тех же входных данных. Суть мемоизации заключается в кешировании результатов функции на основе аргументов, что позволяет сократить время выполнения, особенно для функций с большими вычислительными затратами.

### Пример мемоизации:

```javascript
function expensiveCalculation(n) {
  console.log("Вычисление для", n);
  return n * 2;
}

function memoizedCalculation() {
  let cache = {}; // Кеш для результатов

  return function (n) {
    if (n in cache) {
      console.log("Используется кеш для", n);
      return cache[n];
    } else {
      cache[n] = expensiveCalculation(n);
      return cache[n];
    }
  };
}

const memoized = memoizedCalculation();

console.log(memoized(5)); // Первый вызов, вычисление для 5
console.log(memoized(5)); // Используется кеш для 5
console.log(memoized(8)); // Первый вызов, вычисление для 8
console.log(memoized(8)); // Используется кеш для 8
```

В этом примере `memoizedCalculation()` возвращает функцию, которая использует кеш для хранения результатов `expensiveCalculation()`. При первом вызове функции с определенным аргументом результат вычисления сохраняется в кеше, а при последующих вызовах для того же аргумента результат берется из кеша, что сэкономит время и вычислительные ресурсы.

## Что такое хойстинг (hoisting) в JavaScript?

Хостинг (hoisting) в JavaScript - это поведение, при котором объявления переменных и функций перемещаются в начало своей области видимости во время компиляции (до выполнения кода). Это может привести к тому, что вы можете обращаться к переменным или функциям до их фактического объявления.

### Пример хойстинга переменных:

```javascript
console.log(message); // undefined, но не будет ошибки
var message = "Привет, хойстинг!";
console.log(message); // "Привет, хостинг!"
```

Первый вызов `console.log()` покажет `undefined`, потому что переменная `message` уже поднята (hoisted) в начало области видимости, но ей еще не присвоено значение. Второй вызов покажет фактическое значение переменной.

### Пример хойстинга функций:

```javascript
greet(); // "Привет, хойстинг функций!"

function greet() {
  console.log("Привет, хойстинг функций!");
}
```

В этом примере функция `greet()` также поднимается в начало области видимости, поэтому её можно вызвать до фактического объявления.

Хойстинг может быть запутанным и привести к неожиданным результатам, поэтому рекомендуется всегда объявлять переменные и функции перед их использованием.

## Что такое классы в ES6 (ECMAScript 2015)?

Классы в ES6 представляют собой синтаксический сахар для создания объектно-ориентированных шаблонов. Они предоставляют более удобный способ создания конструкторов и прототипов, с помощью которых можно создавать объекты с общими свойствами и методами.

### Пример класса в ES6:

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(`Привет, меня зовут ${this.name} и мне ${this.age} лет.`);
  }
}

const person1 = new Person("Алиса", 25);
person1.sayHello(); // "Привет, меня зовут Алиса и мне 25 лет."
```

В этом примере `Person` - это класс, который имеет конструктор и метод `sayHello()`. Конструктор используется для инициализации свойств объекта, а метод `sayHello()` выводит информацию о человеке.

Классы также могут иметь методы `get` и `set` для работы с свойствами объекта, а также наследоваться с помощью ключевого слова `extends`.

### Пример использования наследования:

```javascript
class Student extends Person {
  constructor(name, age, course) {
    super(name, age);
    this.course = course;
  }

  study() {
    console.log(`${this.name} изучает курс ${this.course}.`);
  }
}

const student1 = new Student("Боб", 21, "Информатика");
student1.sayHello(); // "Привет, меня зовут Боб и мне 21 год."
student1.study(); // "Боб изучает курс Информатика."
```

В этом примере `Student` наследует свойства и методы от класса `Person` и добавляет свои собственные.

## Что такое замыкания (closures) в JavaScript?

Замыкания (closures) в JavaScript - это феномен, при котором функция сохраняет доступ к переменным из внешней области видимости, даже после завершения выполнения этой функции. Это позволяет функции "запомнить" значения переменных, существующих в том контексте, в котором она была создана.

### Пример замыкания:

```javascript
function createCounter() {
  let count = 0;

  return function () {
    count++;
    return count;
  };
}

const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

В этом примере `createCounter()` возвращает функцию, которая имеет доступ к переменной `count`, хотя `createCounter()` уже выполнена. Это происходит из-за замыкания: функция "запоминает" контекст, в котором она была создана, и сохраняет доступ к переменным этого контекста.

Замыкания часто используются для создания частных переменных и данных, скрытых от глобальной области видимости, и для создания функций обратного вызова.

### Пример использования замыкания в функции обратного вызова:

```javascript
function doSomething(callback) {
  let result = 42;
  callback(result);
}

doSomething(function (data) {
  console.log("Получено:", data); // "Получено: 42"
});
```

Функция обратного вызова сохраняет доступ к переменной `result` благодаря замыканию.

## Что такое модули (modules) в JavaScript?

Модули (modules) в JavaScript - это механизм организации кода, который позволяет разбивать программу на небольшие независимые части, называемые модулями. Каждый модуль содержит свои функции, переменные, классы и другие сущности, и предоставляет интерфейс для работы с ними. Модули помогают управлять сложностью кода, обеспечивая изоляцию и переиспользуемость.

### Пример модуля в ES6:

```javascript
// Модуль в файле math.js
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

// Другой файл
import { add, subtract } from "./math.js";

console.log(add(5, 3)); // 8
console.log(subtract(10, 4)); // 6
```

В этом примере модуль `math.js` экспортирует функции `add` и `subtract`, которые могут быть импортированы и использованы в другом файле.

Модули также могут экспортировать и импортировать по умолчанию, а также содержать частные (недоступные извне) и публичные (доступные извне) члены.

### Пример экспорта и импорта по умолчанию:

```javascript
// Модуль в файле greetings.js
export default function greet(name) {
  return `Привет, ${name}!`;
}

// Другой файл
import greet from "./greetings.js";

console.log(greet("Алиса")); // "Привет, Алиса!"
```

В этом примере функция `greet` экспортируется по умолчанию и импортируется в другом файле без фигурных скобок.

## Зачем нужны модули?

Модули в программировании используются для структурирования кода, обеспечения изоляции, повторного использования и поддержки масштабируемости. Они позволяют разбивать сложные программы на более мелкие и логически связанные части, что упрощает их разработку, сопровождение и понимание.

Преимущества использования модулей:

1. **Изоляция**: Модули создают свою собственную область видимости, что предотвращает конфликты имён и позволяет объявлять частные члены, недоступные извне модуля.

2. **Переиспользование**: Модули могут быть повторно использованы в разных частях программы или даже в разных проектах. Это способствует снижению дублирования кода и упрощает обновление.

3. **Разделение ответственности**: Модули позволяют разделить функциональность программы на логические блоки, каждый из которых отвечает за свою часть задачи.

4. **Улучшение читаемости**: Модули делают код более читаемым, так как позволяют сконцентрироваться на отдельных аспектах приложения.

5. **Масштабируемость**: Разбиение программы на модули делает проект более масштабируемым. Вы можете добавлять и изменять функциональность в одном модуле, не затрагивая другие части кода.

### Пример использования модулей:

Предположим, у вас есть проект веб-приложения, и вы хотите отделить логику работы с базой данных от логики отображения. Вы можете создать два модуля: один для работы с базой данных и другой для управления пользовательским интерфейсом. Это упростит разработку, позволит разработчикам концентрироваться на своей области ответственности и улучшит общую структуру проекта.

## Что такое область видимости (scope) в JavaScript?

Область видимости (scope) в JavaScript определяет, где и какие переменные и функции будут видимы и доступны в определенной части кода. Область видимости контролирует, какие имена переменных можно использовать в данной части программы и какие не мешают друг другу.

### Пример области видимости:

```javascript
function outer() {
  let outerVar = "Я виден только внутри outer()";

  function inner() {
    let innerVar = "Я виден только внутри inner()";
    console.log(innerVar); // "Я виден только внутри inner()"
    console.log(outerVar); // "Я виден только внутри outer()"
  }

  inner();

  // Нельзя обратиться к innerVar здесь
}

// Нельзя обратиться к outerVar здесь
```

В этом примере функция `inner()` имеет доступ как к переменной `innerVar`, так и к переменной `outerVar`, потому что она находится внутри области видимости функции `outer()`. Однако переменная `innerVar` недоступна за пределами функции `inner()`, и переменная `outerVar` недоступна за пределами функции `outer()`.

Область видимости может быть глобальной или локальной. Глобальная область видимости означает, что переменная или функция доступны во всем коде, а локальная область видимости ограничивает доступ только внутри определенной функции или блока кода.
