## Способы создания объекта

1. Литеральная нотация:

```
var obj = {}; // пустой объект
var person = {
  name: "John",
  age: 30,
  location: "New York"
};
```

2. Функция-конструктор:

```
function Person(name, age, location) {
  this.name = name;
  this.age = age;
  this.location = location;
}

var john = new Person("John", 30, "New York");
```

3. Object.create():

```
var personProto = {
  sayHello: function() {
    console.log("Hello!");
  }
};

var john = Object.create(personProto);
john.name = "John";
john.age = 30;
john.location = "New York";
```

4. Class (введена в ECMAScript 2015):

```
class Person {
  constructor(name, age, location) {
    this.name = name;
    this.age = age;
    this.location = location;
  }
}

var john = new Person("John", 30, "New York");
```

## Цепочка прототипов

Прототипное наследование в JavaScript основано на концепции цепочки прототипов, или прототипной цепочки. Каждый объект в JavaScript имеет свойство прототипа (**proto**), которое ссылается на другой объект, называемый прототипом.

Если свойство не найдено в самом объекте, JavaScript будет искать его в прототипе, а затем в прототипе прототипа, и так далее, пока не будет найдено свойство или прототип станет равным null. Эта последовательность поиска свойств называется прототипной цепочкой.

Прототипное наследование позволяет объекту наследовать свойства своего прототипа. Если свойство не найдено в самом объекте, оно будет искаться в его прототипе и так далее. Это позволяет создавать иерархии объектов, где более специфичные объекты наследуют свойства от более общих объектов.

Например, если у объекта `obj` нет свойства `x`, JavaScript будет искать его в `obj.__proto__`, затем в `obj.__proto__.__proto__` и так далее, пока не будет найдено либо встретится null.

## Разница между `call`, `apply` и `bind`

В JavaScript, методы `call`, `apply` и `bind` используются для установки контекста выполнения функции и передачи аргументов.

Метод `call` вызывает функцию с заданным контекстом и передает аргументы в виде отдельных значений. Синтаксис: `function.call(context, arg1, arg2, ...)`.

Метод `apply` также вызывает функцию с заданным контекстом, но передает аргументы в виде массива. Синтаксис: `function.apply(context, [arg1, arg2, ...])`.

Метод `bind` создает новую функцию, привязывая ее к определенному контексту выполнения и, при необходимости, предоставляя некоторые аргументы. Этот метод не вызывает функцию немедленно, а возвращает новую функцию, которую можно вызвать позже. Синтаксис: `function.bind(context, arg1, arg2, ...)`. Вызов новой функции `bind` с переданными аргументами вызовет исходную функцию с указанным контекстом.

Основное отличие между `call`, `apply` и `bind` заключается в способе передачи аргументов. `call` передает аргументы в виде отдельных значений, `apply` передает аргументы в виде массива, а `bind` создает новую функцию с предустановленными аргументами.

## Json и основные операции с ним

JSON (JavaScript Object Notation) - это формат обмена данными, основанный на языке JavaScript. Он используется для передачи структурированных данных между клиентским и серверным приложениями. JSON представляет данные в удобном для чтения и записи формате и легко интерпретируется как людьми, так и компьютерами.

Основные операции, которые можно выполнять с JSON, включают следующее:

1. Создание JSON-объекта: Можно создавать JSON-объекты, используя фигурные скобки {}. Внутри объекта можно определить пары "ключ-значение".

2. Запись данных в JSON: Значения могут быть строками, числами, логическими значениями (true/false), null или другими JSON-объектами или массивами.

3. Чтение данных из JSON: Можно обратиться к значениям в JSON с помощью их ключей и получить доступ к содержимому.

4. Обновление данных в JSON: Можно обновлять значения, присваивая новые значения ключам.

5. Удаление данных из JSON: Ключи и их значения могут быть удалены из JSON-объекта.

6. Парсинг и сериализация: JSON может быть преобразован из строки в формате JSON в структуру данных и обратно с помощью парсинга и сериализации.

JSON является широко распространенным форматом данных, который часто используется в веб-разработке и API. Он легко читается компьютерами и людьми, и может быть использован практически на любом языке программирования.

## Для чего нужен метод slice

Метод `slice()` в JavaScript используется для создания нового массива, содержащего копию части исходного массива. Он позволяет выбирать элементы из исходного массива, начиная с указанного индекса и до определенного индекса (не включая его).

Синтаксис метода `slice()` выглядит следующим образом:

```javascript
array.slice(start, end);
```

Где:

- `start` - необязательный параметр, определяющий индекс, с которого начинается выбор элементов. Если `start` не указан, метод начинает выбор с индекса 0.
- `end` - необязательный параметр, указывающий индекс, до которого выбираются элементы. Метод выбирает элементы до этого индекса, но не включая его. Если `end` не указан, метод выбирает все элементы от `start` до конца массива.

Метод `slice()` возвращает новый массив, содержащий выбранные элементы. Исходный массив при этом не изменяется.

Пример использования метода `slice()`:

```javascript
let fruits = ["apple", "banana", "orange", "grapefruit", "kiwi"];

let citrus = fruits.slice(2, 4);
console.log(citrus); // ['orange', 'grapefruit']

let lastTwo = fruits.slice(-2);
console.log(lastTwo); // ['grapefruit', 'kiwi']

let copy = fruits.slice();
console.log(copy); // ['apple', 'banana', 'orange', 'grapefruit', 'kiwi']
```

В первом примере метод `slice(2, 4)` выбирает элементы с индексами 2 и 3 из массива `fruits` и возвращает новый массив `['orange', 'grapefruit']`.

Во втором примере метод `slice(-2)` выбирает последние два элемента из массива `fruits` и возвращает новый массив `['grapefruit', 'kiwi']`.

В последнем примере метод `slice()` без аргументов создает копию исходного массива `fruits` и возвращает новый массив `['apple', 'banana', 'orange', 'grapefruit', 'kiwi']`.

## Для чего нужен метод splice

Метод `splice()` в JavaScript используется для изменения содержимого массива путем удаления, замены или добавления элементов. Он может принимать несколько аргументов, включая индекс начала изменения, количество элементов для удаления и элементы, которые нужно добавить.

Например, если мы хотим удалить элементы из массива, мы можем использовать `splice()` следующим образом:

```javascript
const fruits = ["яблоко", "груша", "банан", "апельсин"];

// Удаляем один элемент начиная с индекса 1
fruits.splice(1, 1);
// Результат: ['яблоко', 'банан', 'апельсин']

// Удаляем два элемента начиная с индекса 0 и заменяем их другими элементами
fruits.splice(0, 2, "манго", "киви");
// Результат: ['манго', 'киви', 'банан', 'апельсин']
```

Таким образом, метод `splice()` позволяет нам гибко изменять содержимое массива, добавлять новые элементы и удалять существующие.

## Разница между `slice()` и `splice()`

Методы `slice()` и `splice()` в JavaScript имеют разные цели и функциональность.

Метод `slice()` используется для создания нового массива, который будет содержать выбранные элементы из исходного массива. Он принимает два аргумента: начальный индекс и конечный индекс (не включая сам элемент с указанным конечным индексом). `slice()` возвращает новый массив, содержащий выбранные элементы, исходный массив остается неизменным.

Пример использования `slice()`:

```javascript
const fruits = ["яблоко", "груша", "банан", "апельсин"];

const selectedFruits = fruits.slice(1, 3);
// Результат: ['груша', 'банан']
```

Метод `splice()`, напротив, изменяет исходный массив, позволяя удалять, заменять или добавлять элементы. Он принимает несколько аргументов, включая индекс начала изменений, количество элементов для удаления, а также элементы, которые нужно добавить в массив. `splice()` возвращает массив удаленных элементов или пустой массив (если ничего не было удалено).

Пример использования `splice()`:

```javascript
const fruits = ["яблоко", "груша", "банан", "апельсин"];

fruits.splice(1, 2);
// Результат: ['яблоко', 'апельсин']

fruits.splice(1, 0, "манго", "киви");
// Результат: ['яблоко', 'манго', 'киви', 'апельсин']
```

Таким образом, основное отличие между `slice()` и `splice()` заключается в том, что `slice()` создает новый массив, содержащий выбранные элементы, не изменяя исходный массив, а `splice()` изменяет исходный массив путем удаления, замены или добавления элементов.

## Как сравнить Object и Map

Объекты (Objects) и карты (Maps) являются структурами данных в JavaScript и используются для хранения пар ключ-значение. Однако у них есть некоторые различия в функциональности и использовании.

Объекты в JavaScript являются коллекциями свойств, где каждое свойство имеет имя (ключ) и соответствующее значение. Ключи в объектах являются строками или символами. Объекты поддерживают доступ к значениям по ключу, добавление и удаление свойств, итерацию по свойствам и прочие операции. Однако у объектов также есть прототипы и методы, которые позволяют наследовать и расширять свойства и функциональность объектов.

Map, с другой стороны, является коллекцией, где значения хранятся в виде пар ключ-значение. Ключи в Map могут быть любого типа данных, включая объекты и функции. Map поддерживает операции добавления, удаления и обновления пар ключ-значение, а также получение значения по ключу. Он также предоставляет методы для итерации по парам ключ-значение и общую информацию о размере коллекции.

Основная разница между объектами и картами заключается в том, что объекты лучше подходят для создания и управления свойствами с определенной структурой, тогда как карты обеспечивают более гибкую структуру данных и позволяют использовать любой тип данных в качестве ключа. Кроме того, карты имеют лучшую производительность в случаях, когда требуется частое добавление и удаление пар ключ-значение.

## Разница между операторами '==' и '==='

Оператор "==" используется для сравнения значений двух операндов и возвращает true, если значения равны. Однако, при использовании оператора "==" не происходит проверка на тип данных операндов.

Оператор "===" (тройное равенство) используется для строгого сравнения значений и типов данных двух операндов. Он возвращает true, только если значения и типы данных операндов полностью совпадают.

Например:

1 == "1" возвращает true, так как значения равны, несмотря на разные типы данных (число и строка).

1 === "1" возвращает false, так как значения отличаются и типы данных тоже отличны (число и строка).

## Лямбда функции и стрелочные функции

Лямбда-функции или стрелочные функции в JavaScript представляют собой сокращенный синтаксис для создания функций. Они были добавлены в стандарт ECMAScript 6 (ES6) и позволяют определить функции более компактно и кратко.

Синтаксис лямбда-функции выглядит следующим образом:

(parameter1, parameter2, ..., parameterN) => {
// код функции
}

Этот синтаксис позволяет передавать параметры функции в скобках и описывать тело функции после стрелки (=>). Если тело функции состоит из единственного выражения, то оно может быть написано без фигурных скобок. В этом случае значение этого выражения автоматически станет возвращаемым значением функции.

Примеры использования лямбда-функций:

// Обычная функция
function multiply(a, b) {
return a \* b;
}

// Лямбда-функция
const multiply = (a, b) => a \* b;

// Вызов функции
console.log(multiply(2, 3)); // Выведет 6

Лямбда-функции очень удобны в тех случаях, когда требуется использовать функции как аргументы в других функциях (например, методы массивов, такие как map, filter, reduce и т.д.), либо для определения кратких, однострочных функций.

## Что такое функция первого класса в JavaScript?

Функция первого класса в JavaScript - это функция, которая может быть присвоена переменной, передана как аргумент в другую функцию и возвращена из функции в качестве результата. В JavaScript функции являются объектами и могут быть использованы также, как и другие типы данных, такие как строки или числа. Это означает, что функции могут быть сохранены в переменных, использованы в качестве аргументов других функций и возвращены из функций. Функции первого класса играют важную роль в функциональном программировании и позволяют использовать функции в качестве модулей, создавать замыкания и применять другие функциональные парадигмы программирования.

## Функции первого порядка

функция, которая может быть присвоена переменной, передана как аргумент в другую функцию или возвращена как результат другой функции. Такие функции могут быть использованы как любые другие значения в языке программирования.

Вот пример первоклассной функции в JavaScript:

```javascript
function sayHello(name) {
  console.log("Привет, " + name + "!");
}

var greeting = sayHello; // присвоение функции переменной
greeting("Максим"); // вызов функции через переменную
```

В данном примере функция `sayHello` присваивается переменной `greeting` и далее вызывается через эту переменную. Это один из примеров использования первоклассных функций в JavaScript.

## Что такое функция высшего порядка в JavaScript?

Функция высшего порядка (higher order function) в JavaScript - это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию в качестве результата. Это особое свойство языка, которое позволяет работать с функциями как с данными и использовать их в различных сценариях.

Пример функции высшего порядка в JavaScript:

```javascript
function multiplyBy(factor) {
  return function (number) {
    return number * factor;
  };
}

var multiplyByTwo = multiplyBy(2);
var multiplyByThree = multiplyBy(3);

console.log(multiplyByTwo(4)); // Вывод: 8
console.log(multiplyByThree(4)); // Вывод: 12
```

В этом примере функция `multiplyBy` принимает фактор и возвращает анонимную функцию, которая умножает число на данный фактор. Затем функции `multiplyByTwo` и `multiplyByThree` используются для умножения чисел на 2 и 3 соответственно.

Функции высшего порядка являются мощным инструментом в JavaScript и могут быть использованы для создания более гибкого и абстрактного кода.

## Унарная функция

Унарная функция (unary function) в JavaScript - это функция, которая принимает только один аргумент. Она обрабатывает этот аргумент и возвращает результат. Вот пример унарной функции на русском языке:

```javascript
// Унарная функция, преобразующая число в его квадрат
function квадрат(число) {
  return число * число;
}

// Вызов унарной функции
let число = 5;
let квадратЧисла = квадрат(число);
console.log(квадратЧисла); // Выведет 25
```

## Что такое каррирование в JavaScript?

Каррирование (currying) - это техника функционального программирования, которая позволяет превратить функцию с несколькими аргументами в последовательность функций, каждая из которых принимает только один аргумент.

Вот пример каррированной функции на русском языке, которая складывает два числа:

```javascript
// Каррированная функция, складывающая два числа
function сложить(a) {
  return function (b) {
    return a + b;
  };
}

// Вызов каррированной функции
let результат = сложить(2)(3);
console.log(результат); // Выведет 5
```

В этом примере `сложить(2)` возвращает функцию, которая принимает один аргумент `b` и возвращает сумму `a + b`. Затем `сложить(2)(3)` принимает второй аргумент `3` и возвращает результат сложения `2 + 3`.

## Что такое чистая функция в JavaScript?

Чистая функция (pure function) - это функция, которая всегда возвращает одинаковый результат при одинаковых входных данных и не имеет побочных эффектов. Она не изменяет состояние программы или какие-либо внешние переменные.

Вот пример чистой функции на русском языке, которая складывает два числа:

```javascript
// Чистая функция, складывающая два числа
function сложить(a, b) {
  return a + b;
}

// Вызов чистой функции
let результат = сложить(2, 3);
console.log(результат); // Выведет 5
```

В этом примере функция `сложить` всегда возвращает одинаковый результат для одних и тех же входных данных `a` и `b`, и она не влияет на состояние программы или внешние переменные.

## Какова цель ключевого слова "let" в JavaScript?

В JavaScript ключевое слово "let" используется для объявления блочной переменной, которая имеет область видимости ограниченную блоком кода, в котором она объявлена. Это отличается от ключевого слова "var", которое имеет функциональную область видимости.

Вот пример использования ключевого слова "let" на русском языке:

```javascript
function примерФункции() {
  if (условие) {
    let переменная = "Значение переменной";
    console.log(переменная); // Выведет "Значение переменной"
  }

  console.log(переменная); // Вызовет ошибку ReferenceError: переменная is not defined
}

примерФункции();
```

В этом примере переменная "переменная" объявлена с помощью ключевого слова "let" внутри блока кода условия. Она доступна только внутри этого блока, и обращение к ней за пределами блока вызовет ошибку.

## В чем разница между let и var в JavaScript?

В JavaScript существуют два ключевых слова для объявления переменных: `let` и `var`. Вот основные различия между ними:

1. Область видимости (scope):

   - Переменные, объявленные с помощью `var`, имеют функциональную область видимости. Это означает, что они доступны внутри функции, в которой они объявлены, независимо от блока кода.
   - Переменные, объявленные с помощью `let`, имеют блочную область видимости. Они доступны только в пределах блока кода, в котором они объявлены.

2. Поднятие (hoisting):

   - Переменные, объявленные с помощью `var`, поднимаются (hoisting) вверх области видимости. Это означает, что их можно использовать до того, как они были объявлены в коде.
   - Переменные, объявленные с помощью `let`, не поднимаются. Они существуют только после того, как они были объявлены в коде.

3. Повторное объявление:
   - Переменные, объявленные с помощью `var`, могут быть повторно объявлены в той же области видимости без вызова ошибки. Новое значение будет присвоено переменной.
   - Переменные, объявленные с помощью `let`, не могут быть повторно объявлены в той же области видимости. Попытка повторного объявления вызовет ошибку.

Вот пример, демонстрирующий разницу между `let` и `var` на русском языке:

```javascript
function примерФункции() {
  if (true) {
    var переменнаяVar = "Значение var";
    let переменнаяLet = "Значение let";
  }

  console.log(переменнаяVar); // Выведет "Значение var"
  console.log(переменнаяLet); // Вызовет ошибку ReferenceError: переменнаяLet is not defined
}

примерФункции();
```

В этом примере переменная `переменнаяVar`, объявленная с помощью `var`, доступна за пределами блока кода условия. Однако переменная `переменнаяLet`, объявленная с помощью `let`, не доступна за пределами блока и вызовет ошибку.

## Как переопределить переменные в блоке switch без ошибки в JavaScript?

В JavaScript, переменные внутри блока switch могут быть переопределены без ошибки, так как блок switch создает свою собственную область видимости для каждого случая (case). Это позволяет использовать одно и то же имя переменной в разных случаях без конфликтов.

Пример:

```javascript
let option = 2;
switch (option) {
  case 1:
    let message = "Первый вариант";
    console.log(message);
    break;
  case 2:
    let message = "Второй вариант"; // Нет ошибки, так как это отдельная область видимости
    console.log(message);
    break;
  default:
    let message = "Другой вариант";
    console.log(message);
}
```

В этом примере каждый блок case имеет свою собственную область видимости для переменной `message`, поэтому нет ошибок при переопределении переменной внутри блока switch.

## Что такое "Temporal Dead Zone" в JavaScript?

"Temporal Dead Zone" (временная мертвая зона) в JavaScript - это период существования переменной, когда она уже была объявлена с использованием ключевых слов `let` или `const`, но еще не может быть использована до тех пор, пока не будет до нее достигнут код выполнения. В этот период попытка доступа к переменной приведет к ошибке.

Это связано с тем, что переменные, объявленные с использованием `let` и `const`, имеют блочную область видимости и не подвергаются "всплытию" (hoisting) в начало своего блока. Они существуют только после объявления и до того момента, как выполнение программы достигнет строки, на которой они были объявлены.

Пример:

```javascript
console.log(name); // Будет ошибка временной мертвой зоны
let name = "Alice";
```

В этом примере будет ошибка "ReferenceError", потому что переменная `name` уже объявлена, но на момент вывода она все еще находится во временной мертвой зоне, и к ней нельзя обратиться до фактического объявления.

## Что такое IIFE (Immediately Invoked Function Expression) в JavaScript?

IIFE (Immediately Invoked Function Expression) в JavaScript - это паттерн, при котором функция определяется и немедленно вызывается (выполняется) в том же месте, где она была объявлена. Этот подход позволяет создать локальную область видимости для изолирования переменных и кода, исключая возможные конфликты имён с другими частями программы.

Пример:

```javascript
(function () {
  var message = "Привет из IIFE!";
  console.log(message);
})(); // Функция вызывается сразу после объявления

// Нельзя обратиться к переменной message вне IIFE, так как она находится в её области видимости
console.log(message); // Это вызовет ошибку
```

Здесь анонимная функция определена внутри круглых скобок `(function() {...})` и сразу же вызывается, заключив `()` в конце. Это создает свою область видимости, в которой можно безопасно определять переменные, не затрагивая глобальное пространство имён.

## Как декодировать или закодировать URL в JavaScript?

В JavaScript для декодирования (преобразования из закодированного вида в читаемый) или кодирования (преобразования из читаемого вида в закодированный) URL используются методы `decodeURI()`, `encodeURI()`, `decodeURIComponent()` и `encodeURIComponent()`.

### Декодирование:

- `decodeURI()` используется для декодирования всего URL.
- `decodeURIComponent()` применяется для декодирования компонентов URL, таких как параметры.

Пример декодирования:

```javascript
let encodedURL =
  "https%3A%2F%2Fexample.com%2F%3Fq%3D%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80";
let decodedURL = decodeURIComponent(encodedURL);
console.log(decodedURL);
```

### Кодирование:

- `encodeURI()` используется для кодирования всего URL.
- `encodeURIComponent()` применяется для кодирования компонентов URL, чтобы делать их безопасными для передачи.

Пример кодирования:

```javascript
let url = "https://example.com/?q=пример";
let encodedURL = encodeURI(url);
console.log(encodedURL);
```

При использовании `encodeURIComponent()`:

```javascript
let query = "пример запроса";
let encodedQuery = encodeURIComponent(query);
console.log(encodedQuery);
```

Важно понимать разницу между этими методами и выбирать правильный в зависимости от контекста.

## Что такое мемоизация (memoization) в JavaScript?

Мемоизация (memoization) в JavaScript - это оптимизационная техника, которая заключается в сохранении результатов выполнения дорогостоящих функций, чтобы избежать повторных вычислений при одних и тех же входных данных. Суть мемоизации заключается в кешировании результатов функции на основе аргументов, что позволяет сократить время выполнения, особенно для функций с большими вычислительными затратами.

### Пример мемоизации:

```javascript
function expensiveCalculation(n) {
  console.log("Вычисление для", n);
  return n * 2;
}

function memoizedCalculation() {
  let cache = {}; // Кеш для результатов

  return function (n) {
    if (n in cache) {
      console.log("Используется кеш для", n);
      return cache[n];
    } else {
      cache[n] = expensiveCalculation(n);
      return cache[n];
    }
  };
}

const memoized = memoizedCalculation();

console.log(memoized(5)); // Первый вызов, вычисление для 5
console.log(memoized(5)); // Используется кеш для 5
console.log(memoized(8)); // Первый вызов, вычисление для 8
console.log(memoized(8)); // Используется кеш для 8
```

В этом примере `memoizedCalculation()` возвращает функцию, которая использует кеш для хранения результатов `expensiveCalculation()`. При первом вызове функции с определенным аргументом результат вычисления сохраняется в кеше, а при последующих вызовах для того же аргумента результат берется из кеша, что сэкономит время и вычислительные ресурсы.

## Что такое хойстинг (hoisting) в JavaScript?

Хостинг (hoisting) в JavaScript - это поведение, при котором объявления переменных и функций перемещаются в начало своей области видимости во время компиляции (до выполнения кода). Это может привести к тому, что вы можете обращаться к переменным или функциям до их фактического объявления.

### Пример хойстинга переменных:

```javascript
console.log(message); // undefined, но не будет ошибки
var message = "Привет, хойстинг!";
console.log(message); // "Привет, хостинг!"
```

Первый вызов `console.log()` покажет `undefined`, потому что переменная `message` уже поднята (hoisted) в начало области видимости, но ей еще не присвоено значение. Второй вызов покажет фактическое значение переменной.

### Пример хойстинга функций:

```javascript
greet(); // "Привет, хойстинг функций!"

function greet() {
  console.log("Привет, хойстинг функций!");
}
```

В этом примере функция `greet()` также поднимается в начало области видимости, поэтому её можно вызвать до фактического объявления.

Хойстинг может быть запутанным и привести к неожиданным результатам, поэтому рекомендуется всегда объявлять переменные и функции перед их использованием.

## Что такое классы в ES6 (ECMAScript 2015)?

Классы в ES6 представляют собой синтаксический сахар для создания объектно-ориентированных шаблонов. Они предоставляют более удобный способ создания конструкторов и прототипов, с помощью которых можно создавать объекты с общими свойствами и методами.

### Пример класса в ES6:

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(`Привет, меня зовут ${this.name} и мне ${this.age} лет.`);
  }
}

const person1 = new Person("Алиса", 25);
person1.sayHello(); // "Привет, меня зовут Алиса и мне 25 лет."
```

В этом примере `Person` - это класс, который имеет конструктор и метод `sayHello()`. Конструктор используется для инициализации свойств объекта, а метод `sayHello()` выводит информацию о человеке.

Классы также могут иметь методы `get` и `set` для работы с свойствами объекта, а также наследоваться с помощью ключевого слова `extends`.

### Пример использования наследования:

```javascript
class Student extends Person {
  constructor(name, age, course) {
    super(name, age);
    this.course = course;
  }

  study() {
    console.log(`${this.name} изучает курс ${this.course}.`);
  }
}

const student1 = new Student("Боб", 21, "Информатика");
student1.sayHello(); // "Привет, меня зовут Боб и мне 21 год."
student1.study(); // "Боб изучает курс Информатика."
```

В этом примере `Student` наследует свойства и методы от класса `Person` и добавляет свои собственные.

## Что такое замыкания (closures) в JavaScript?

Замыкания (closures) в JavaScript - это феномен, при котором функция сохраняет доступ к переменным из внешней области видимости, даже после завершения выполнения этой функции. Это позволяет функции "запомнить" значения переменных, существующих в том контексте, в котором она была создана.

### Пример замыкания:

```javascript
function createCounter() {
  let count = 0;

  return function () {
    count++;
    return count;
  };
}

const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

В этом примере `createCounter()` возвращает функцию, которая имеет доступ к переменной `count`, хотя `createCounter()` уже выполнена. Это происходит из-за замыкания: функция "запоминает" контекст, в котором она была создана, и сохраняет доступ к переменным этого контекста.

Замыкания часто используются для создания частных переменных и данных, скрытых от глобальной области видимости, и для создания функций обратного вызова.

### Пример использования замыкания в функции обратного вызова:

```javascript
function doSomething(callback) {
  let result = 42;
  callback(result);
}

doSomething(function (data) {
  console.log("Получено:", data); // "Получено: 42"
});
```

Функция обратного вызова сохраняет доступ к переменной `result` благодаря замыканию.

## Что такое модули (modules) в JavaScript?

Модули (modules) в JavaScript - это механизм организации кода, который позволяет разбивать программу на небольшие независимые части, называемые модулями. Каждый модуль содержит свои функции, переменные, классы и другие сущности, и предоставляет интерфейс для работы с ними. Модули помогают управлять сложностью кода, обеспечивая изоляцию и переиспользуемость.

### Пример модуля в ES6:

```javascript
// Модуль в файле math.js
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

// Другой файл
import { add, subtract } from "./math.js";

console.log(add(5, 3)); // 8
console.log(subtract(10, 4)); // 6
```

В этом примере модуль `math.js` экспортирует функции `add` и `subtract`, которые могут быть импортированы и использованы в другом файле.

Модули также могут экспортировать и импортировать по умолчанию, а также содержать частные (недоступные извне) и публичные (доступные извне) члены.

### Пример экспорта и импорта по умолчанию:

```javascript
// Модуль в файле greetings.js
export default function greet(name) {
  return `Привет, ${name}!`;
}

// Другой файл
import greet from "./greetings.js";

console.log(greet("Алиса")); // "Привет, Алиса!"
```

В этом примере функция `greet` экспортируется по умолчанию и импортируется в другом файле без фигурных скобок.

## Зачем нужны модули?

Модули в программировании используются для структурирования кода, обеспечения изоляции, повторного использования и поддержки масштабируемости. Они позволяют разбивать сложные программы на более мелкие и логически связанные части, что упрощает их разработку, сопровождение и понимание.

Преимущества использования модулей:

1. **Изоляция**: Модули создают свою собственную область видимости, что предотвращает конфликты имён и позволяет объявлять частные члены, недоступные извне модуля.

2. **Переиспользование**: Модули могут быть повторно использованы в разных частях программы или даже в разных проектах. Это способствует снижению дублирования кода и упрощает обновление.

3. **Разделение ответственности**: Модули позволяют разделить функциональность программы на логические блоки, каждый из которых отвечает за свою часть задачи.

4. **Улучшение читаемости**: Модули делают код более читаемым, так как позволяют сконцентрироваться на отдельных аспектах приложения.

5. **Масштабируемость**: Разбиение программы на модули делает проект более масштабируемым. Вы можете добавлять и изменять функциональность в одном модуле, не затрагивая другие части кода.

### Пример использования модулей:

Предположим, у вас есть проект веб-приложения, и вы хотите отделить логику работы с базой данных от логики отображения. Вы можете создать два модуля: один для работы с базой данных и другой для управления пользовательским интерфейсом. Это упростит разработку, позволит разработчикам концентрироваться на своей области ответственности и улучшит общую структуру проекта.

## Что такое область видимости (scope) в JavaScript?

Область видимости (scope) в JavaScript определяет, где и какие переменные и функции будут видимы и доступны в определенной части кода. Область видимости контролирует, какие имена переменных можно использовать в данной части программы и какие не мешают друг другу.

### Пример области видимости:

```javascript
function outer() {
  let outerVar = "Я виден только внутри outer()";

  function inner() {
    let innerVar = "Я виден только внутри inner()";
    console.log(innerVar); // "Я виден только внутри inner()"
    console.log(outerVar); // "Я виден только внутри outer()"
  }

  inner();

  // Нельзя обратиться к innerVar здесь
}

// Нельзя обратиться к outerVar здесь
```

В этом примере функция `inner()` имеет доступ как к переменной `innerVar`, так и к переменной `outerVar`, потому что она находится внутри области видимости функции `outer()`. Однако переменная `innerVar` недоступна за пределами функции `inner()`, и переменная `outerVar` недоступна за пределами функции `outer()`.

Область видимости может быть глобальной или локальной. Глобальная область видимости означает, что переменная или функция доступны во всем коде, а локальная область видимости ограничивает доступ только внутри определенной функции или блока кода.

## Что такое сервисный работник (service worker) в JavaScript?

Сервисный работник (service worker) в JavaScript - это скрипт, который выполняется в фоновом режиме, независимо от веб-страницы, которая его зарегистрировала. Сервисные работники широко используются для реализации различных задач, таких как кэширование ресурсов, работа в офлайн-режиме, пуш-уведомления и другие.

Сервисные работники позволяют веб-приложениям быть более отзывчивыми и надежными, предоставляя возможность контролировать сетевые запросы и взаимодействовать с браузером даже в офлайн-режиме.

### Пример использования сервисного работника:

```javascript
// Регистрация сервисного работника
if ("serviceWorker" in navigator) {
  navigator.serviceWorker
    .register("/service-worker.js")
    .then((registration) => {
      console.log("Сервисный работник зарегистрирован:", registration);
    })
    .catch((error) => {
      console.error("Ошибка при регистрации сервисного работника:", error);
    });
}
```

Создайте файл `service-worker.js` и добавьте в него логику работы сервисного работника:

```javascript
// service-worker.js
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open("my-cache").then((cache) => {
      return cache.addAll(["/", "/index.html", "/styles.css", "/script.js"]);
    })
  );
});

self.addEventListener("fetch", (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});
```

В этом примере сервисный работник регистрируется и управляет кэшированием ресурсов. В момент установки работника, он добавляет некоторые ресурсы в кеш, и затем при запросе ресурсов, сервисный работник проверяет, есть ли ресурс в кеше, и возвращает его из кеша, если возможно.

## Как осуществлять изменение DOM с использованием сервисного работника?

Сервисные работники (service workers) не имеют прямого доступа к DOM (Document Object Model) из-за своей асинхронной природы и независимости от конкретных веб-страниц. Однако, вы можете использовать сервисные работники для перехвата сетевых запросов, кеширования ресурсов и динамической загрузки контента в DOM.

### Пример динамической загрузки контента с использованием сервисного работника:

Предположим, у вас есть элемент с идентификатором `dynamic-content`, и вы хотите динамически загрузить контент в него с использованием сервисного работника.

```javascript
// В файле service-worker.js
self.addEventListener("fetch", (event) => {
  if (event.request.url.endsWith("/dynamic-content")) {
    event.respondWith(
      fetch("https://api.example.com/data") // Пример запроса к серверу для получения данных
        .then((response) => response.text())
        .then(
          (data) =>
            new Response(data, { headers: { "Content-Type": "text/html" } })
        )
    );
  }
});
```

В этом примере, при запросе к URL, оканчивающемуся на `/dynamic-content`, сервисный работник перехватывает запрос, отправляет запрос на сервер для получения данных и затем создает и возвращает новый `Response` с этими данными.

```html
<!-- В вашей веб-странице -->
<div id="dynamic-content"></div>

<script>
  // В этом примере JavaScript на вашей веб-странице
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker
      .register("/service-worker.js")
      .then((registration) => {
        console.log("Сервисный работник зарегистрирован:", registration);
      })
      .catch((error) => {
        console.error("Ошибка при регистрации сервисного работника:", error);
      });
  }
</script>
```

В данном примере, при наличии активированного сервисного работника, он будет перехватывать запросы к `/dynamic-content` и вставлять полученный контент в соответствующий элемент DOM на веб-странице.

**Обратите внимание**, что манипуляции DOM непосредственно из сервисного работника невозможны из-за их асинхронной природы и того, что они могут работать вне контекста конкретной страницы.

## Как переиспользовать информацию между перезапусками сервисного работника?

Для переиспользования информации между перезапусками сервисного работника можно использовать браузерное хранилище, такое как `localStorage`, `IndexedDB` или кэш сервисного работника.

### Пример использования кэша сервисного работника для сохранения информации:

```javascript
// В файле service-worker.js

self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open("my-cache").then((cache) => {
      return cache.addAll(["/static-resource"]); // Пример статического ресурса для кэширования
    })
  );
});

self.addEventListener("fetch", (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      if (response) {
        return response;
      }

      return fetch(event.request);
    })
  );
});

self.addEventListener("message", (event) => {
  if (event.data.action === "saveInfo") {
    caches.open("my-cache").then((cache) => {
      cache.put("saved-info", new Response(JSON.stringify(event.data.info)));
    });
  }
});
```

```javascript
// На веб-странице

if ("serviceWorker" in navigator) {
  navigator.serviceWorker
    .register("/service-worker.js")
    .then((registration) => {
      console.log("Сервисный работник зарегистрирован:", registration);
    })
    .catch((error) => {
      console.error("Ошибка при регистрации сервисного работника:", error);
    });
}

navigator.serviceWorker.ready.then((registration) => {
  const savedInfo = { data: "Это сохраненная информация" };

  // Отправляем сообщение сервисному работнику для сохранения информации в кэше
  registration.active.postMessage({ action: "saveInfo", info: savedInfo });
});
```

В этом примере, при установке сервисного работника, статический ресурс (`'/static-resource'`) кэшируется. При перезапуске сервисного работника, сохраненная информация (`savedInfo`) отправляется сервисному работнику через сообщение (`postMessage`), и он сохраняет эту информацию в кэше. Таким образом, информация переиспользуется между перезапусками.

## Что такое IndexedDB в JavaScript?

IndexedDB - это встроенная база данных в браузерах, предназначенная для хранения и управления большими объемами структурированных данных. Она предоставляет возможность веб-приложениям хранить данные на стороне клиента, даже при отсутствии подключения к интернету. Это специальная форма хранилища ключ-значение, где значения могут быть сложными объектами или структурами данных.

### Пример использования IndexedDB:

```javascript
// Открываем или создаем базу данных "my-database" с версией 1
var request = indexedDB.open("my-database", 1);

// Обработчик успешного открытия базы данных
request.onsuccess = function (event) {
  var db = event.target.result;

  // Создаем транзакцию для доступа к объектному хранилищу "my-store"
  var transaction = db.transaction(["my-store"], "readwrite");

  // Получаем объектное хранилище
  var store = transaction.objectStore("my-store");

  // Добавляем данные в хранилище
  store.add({ id: 1, name: "Алиса" });
};

// Обработчик создания или обновления базы данных
request.onupgradeneeded = function (event) {
  var db = event.target.result;

  // Создаем объектное хранилище "my-store" с индексом "name"
  var store = db.createObjectStore("my-store", { keyPath: "id" });
  store.createIndex("name", "name", { unique: false });
};
```

В этом примере создается база данных "my-database" с объектным хранилищем "my-store". Данные добавляются в хранилище с использованием транзакции. Также создается индекс "name" для поиска по имени.

IndexedDB предоставляет более сложные функции по сравнению с простыми хранилищами, такими как `localStorage`, и позволяет производить запросы, индексировать данные и выполнять сложные операции с базой данных на стороне клиента.

## Что такое веб-хранилище (web storage) в JavaScript?

Веб-хранилище (web storage) - это механизм для хранения данных на стороне клиента в браузере. Он предоставляет два объекта, `localStorage` и `sessionStorage`, которые позволяют сохранять данные в формате ключ-значение. Данные хранятся в браузере и доступны даже после перезагрузки страницы.

### Пример использования `localStorage`:

```javascript
// Сохраняем данные в localStorage
localStorage.setItem("username", "Alice");
localStorage.setItem("age", "25");

// Получаем данные из localStorage
const username = localStorage.getItem("username");
const age = localStorage.getItem("age");

console.log(username); // "Alice"
console.log(age); // "25"

// Удаляем данные из localStorage
localStorage.removeItem("username");
localStorage.clear(); // Очищаем все данные
```

### Пример использования `sessionStorage`:

```javascript
// Сохраняем данные в sessionStorage
sessionStorage.setItem("city", "New York");

// Получаем данные из sessionStorage
const city = sessionStorage.getItem("city");

console.log(city); // "New York"

// Удаляем данные из sessionStorage
sessionStorage.removeItem("city");
```

`localStorage` сохраняет данные на неограниченный срок или до тех пор, пока они не будут удалены вручную. `sessionStorage` хранит данные только в течение сессии браузера, и они будут удалены при закрытии вкладки или браузера.

Веб-хранилище обычно используется для сохранения небольших объемов данных, таких как настройки пользователя, состояния приложения или кэширования данных.

## Что такое сообщение postMessage в JavaScript?

Сообщение `postMessage` в JavaScript - это механизм коммуникации между окнами/вкладками браузера, работающими на одном и том же домене. Он позволяет отправлять данные и сообщения от одного окна к другому в безопасной среде.

### Пример использования `postMessage`:

Предположим, у вас есть две веб-страницы, `parent.html` и `child.html`, открытые в разных вкладках браузера.

```html
<!-- parent.html -->
<!DOCTYPE html>
<html>
  <head>
    <title>Родитель</title>
  </head>
  <body>
    <iframe src="child.html" id="childFrame"></iframe>

    <script>
      const childFrame = document.getElementById("childFrame").contentWindow;

      function sendMessage() {
        childFrame.postMessage("Привет, дочка!", "http://localhost:8000"); // Замените на свой домен
      }
    </script>
  </body>
</html>
```

```html
<!-- child.html -->
<!DOCTYPE html>
<html>
  <head>
    <title>Дочь</title>
  </head>
  <body>
    <script>
      window.addEventListener("message", (event) => {
        if (event.origin === "http://localhost:8000") {
          // Замените на свой домен
          console.log("Получено сообщение от родителя:", event.data);
        }
      });
    </script>
  </body>
</html>
```

В этом примере, при вызове функции `sendMessage` на странице `parent.html`, сообщение "Привет, дочка!" будет отправлено во фрейм `child.html`. Фрейм прослушивает событие `message` и выводит полученное сообщение в консоль.

Важно обратить внимание, что `postMessage` безопасен, только если вы явно проверяете источник (поле `event.origin`) при обработке сообщений, чтобы избежать возможных атак через сообщения.

## Что такое cookie (куки)?

Cookie (куки) - это небольшие фрагменты данных, которые веб-сайты отправляют и хранят на компьютере пользователя через веб-браузер. Куки используются для хранения информации о состоянии, настройках пользователя, а также для отслеживания и аутентификации.

### Пример использования cookie:

Предположим, у вас есть веб-сайт, который сохраняет язык, выбранный пользователем.

```javascript
// Записываем значение в cookie
document.cookie =
  "language=english; expires=Fri, 31 Dec 2023 23:59:59 GMT; path=/";

// Чтение значения из cookie
const cookies = document.cookie;
console.log(cookies); // "language=english; ..."
```

В этом примере значение "language=english" записывается в cookie. Это значение будет доступно на всех страницах сайта, которые находятся в той же директории (путь `/`), до указанной даты и времени (здесь до конца 2023 года).

Cookie могут иметь различные параметры, такие как срок годности (`expires`), путь (`path`), домен (`domain`), безопасность (`secure`), и т. д.

Куки могут быть использованы для сохранения сессионной информации, аутентификации пользователя, отслеживания действий пользователя на сайте и других задач. Однако, стоит помнить, что куки имеют ограниченный объем хранения (обычно до 4 килобайт) и могут вызывать проблемы с конфиденциальностью, если не используются правильно.

## Зачем нужны куки (Cookies)?

Куки (Cookies) в веб-разработке используются для хранения информации о состоянии и настройках пользователя на веб-сайте. Они имеют ряд важных применений, включая сессионное управление, аутентификацию, сохранение предпочтений пользователя и отслеживание активности.

### Примеры применения куки:

1. **Сессионное управление**: Куки могут использоваться для отслеживания сессии пользователя. После аутентификации, сервер может установить уникальный идентификатор сессии в куки, что позволяет серверу идентифицировать пользователя между запросами.

2. **Аутентификация**: Куки позволяют сохранить данные аутентификации пользователя. Например, при успешной аутентификации, сервер может установить куки с токеном, который подтверждает аутентичность пользователя.

3. **Сохранение настроек**: Веб-сайты могут использовать куки для сохранения предпочтений пользователя, таких как язык, тема оформления и другие настройки.

4. **Отслеживание активности**: Куки могут использоваться для анализа поведения пользователей на сайте, что помогает в понимании, какие страницы чаще посещаются и какие действия выполняются.

5. **Подготовка корзины покупок**: В интернет-магазинах куки могут использоваться для отслеживания добавленных товаров в корзину, даже если пользователь переходит между страницами.

### Пример использования куки:

Предположим, у вас есть сайт, и вы хотите, чтобы пользователи могли выбрать свою предпочитаемую тему оформления.

```javascript
// При выборе пользователем темы "dark"
document.cookie = "theme=dark; expires=Fri, 31 Dec 2023 23:59:59 GMT; path=/";

// При загрузке страницы
const cookies = document.cookie;
const themeCookie = cookies
  .split("; ")
  .find((cookie) => cookie.startsWith("theme="));

if (themeCookie) {
  const theme = themeCookie.split("=")[1];
  applyTheme(theme);
}
```

В этом примере, при выборе пользователем темы "dark", куки сохраняется, и при следующем посещении сайта применяется выбранная тема.

## Какие параметры можно задать в куки (Cookie)?

Куки (Cookies) имеют различные параметры, которые можно установить для контроля их поведения. Ниже приведены некоторые из наиболее часто используемых параметров.

### Примеры параметров в куки:

1. **`expires` (срок действия)**: Определяет, когда куки истекает и становится недействительным. Значение может быть указано в виде строки с датой и временем в формате GMT.

   ```javascript
   document.cookie =
     "username=John; expires=Fri, 31 Dec 2023 23:59:59 GMT; path=/";
   ```

2. **`path` (путь)**: Определяет путь, для которого куки действительно. Куки будут доступны только для страниц, которые находятся в этом пути.

   ```javascript
   document.cookie =
     "username=John; expires=Fri, 31 Dec 2023 23:59:59 GMT; path=/admin";
   ```

3. **`domain` (домен)**: Определяет домен, для которого куки действительно. По умолчанию, куки доступны только для текущего домена.

   ```javascript
   document.cookie =
     "username=John; expires=Fri, 31 Dec 2023 23:59:59 GMT; domain=example.com";
   ```

4. **`secure` (безопасность)**: Если этот параметр установлен, куки будет передаваться только через защищенное (HTTPS) соединение.

   ```javascript
   document.cookie =
     "username=John; expires=Fri, 31 Dec 2023 23:59:59 GMT; secure";
   ```

5. **`samesite`**: Определяет, как куки будут отправляться на сервер при запросах с других сайтов. Значения могут быть "strict", "lax" или "none".

   ```javascript
   document.cookie =
     "username=John; expires=Fri, 31 Dec 2023 23:59:59 GMT; samesite=lax";
   ```

Эти параметры позволяют более точно управлять поведением куки, определяя, когда и для каких страниц они действительны, а также обеспечивая безопасность и контроль над обменом данными.

## Как удалить куки (Cookie)?

Для удаления куки (Cookie) необходимо установить его срок действия в прошедшее время или использовать опцию "Max-Age" с отрицательным значением. Это приведет к тому, что браузер считает куки недействительным и удалит его.

### Пример удаления куки:

```javascript
// Удаление куки по имени
function deleteCookie(cookieName) {
  document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
}

// Пример вызова функции для удаления куки "username"
deleteCookie("username");
```

В этом примере, функция `deleteCookie` устанавливает срок действия куки "username" в прошедшее время, что приводит к его удалению. Удаление происходит путем установки даты и времени истечения куки (`expires`) на дату в прошлом. Важно указать путь (`path`), который соответствует пути, для которого куки было установлено.

Пожалуйста, обратите внимание, что куки можно удалить только на том же домене и пути, где они были установлены.

## В чем разница между куками (cookie), локальным хранилищем (localStorage) и сессионным хранилищем (sessionStorage)?

Куки (cookie), локальное хранилище (localStorage) и сессионное хранилище (sessionStorage) - это три разных механизма хранения данных на стороне клиента в браузере, и у них есть существенные различия.

### Куки (Cookie):

- Куки являются небольшими фрагментами данных, которые хранятся на стороне клиента.
- Используются для хранения небольших объемов данных и обычно имеют ограничение в размере до 4 килобайт.
- Отправляются в заголовке HTTP-запроса при каждом запросе к серверу, что может замедлить загрузку страницы.
- Имеют параметры срока действия, пути, домена, безопасности и другие.
- Могут быть доступны как на текущей странице, так и на других страницах или доменах в зависимости от настроек параметров.

### Локальное хранилище (localStorage):

- Предоставляет механизм хранения ключ-значение без срока действия (данные остаются даже после перезагрузки браузера).
- Позволяет хранить более объемные данные (обычно до 5-10 мегабайт).
- Данные в локальном хранилище доступны на всех страницах с одинаковым протоколом (http/https) и доменом.
- Доступ к данным возможен через JavaScript из любой вкладки или окна с одним и тем же доменом.

### Сессионное хранилище (sessionStorage):

- Похоже на локальное хранилище, но данные в нем существуют только в рамках текущей сессии браузера.
- Данные сохраняются даже после перезагрузки страницы, но удаляются при закрытии вкладки или браузера.
- Данные из сессионного хранилища доступны только в рамках одной вкладки или окна браузера.
- Подходит для временного хранения данных, которые нужны только в течение текущей сессии.

### Пример сравнения:

Предположим, у вас есть задача сохранить предпочтения пользователя на сайте.

- Используйте куки, если нужно сохранить предпочтения на долгий срок и сделать их доступными на разных устройствах.
- Используйте локальное хранилище, если предпочтения должны оставаться даже после перезагрузки браузера, но не требуется общение между разными вкладками.
- Используйте сессионное хранилище, если предпочтения должны сохраняться в рамках одной вкладки или сессии, и не имеет значения после закрытия браузера.

## В чем основное различие между локальным хранилищем (localStorage) и сессионным хранилищем (sessionStorage)?

Основное различие между локальным хранилищем (localStorage) и сессионным хранилищем (sessionStorage) заключается в продолжительности хранения данных и доступности данных между вкладками браузера.

### Локальное хранилище (localStorage):

- Данные в локальном хранилище сохраняются даже после перезагрузки браузера.
- Данные доступны на всех страницах с одинаковым протоколом (http/https) и доменом.
- Данные могут быть доступны через JavaScript из любой вкладки или окна браузера с тем же доменом.

### Сессионное хранилище (sessionStorage):

- Данные в сессионном хранилище существуют только в рамках текущей сессии браузера.
- Данные сохраняются даже после перезагрузки страницы, но удаляются при закрытии вкладки или браузера.
- Данные из сессионного хранилища доступны только в рамках одной вкладки или окна браузера.

### Пример сравнения:

Допустим, вы разрабатываете веб-приложение для заметок.

- Используйте локальное хранилище (localStorage), если хотите, чтобы заметки оставались доступными даже после закрытия браузера и перезагрузки страницы. Пользователь сможет получить доступ к своим заметкам на разных устройствах и в разных вкладках.
- Используйте сессионное хранилище (sessionStorage), если хотите, чтобы заметки сохранялись только в рамках одной сессии браузера. Например, пользователь может создавать временные заметки, которые автоматически удаляются после закрытия вкладки.

Выбор между `localStorage` и `sessionStorage` зависит от требований к продолжительности хранения данных и ожидаемого поведения на разных устройствах и вкладках.

## Как получить доступ к веб-хранилищу (web storage)?

Для доступа к веб-хранилищу (web storage) в JavaScript используются объекты `localStorage` и `sessionStorage`. Эти объекты позволяют сохранять и извлекать данные на стороне клиента в браузере.

### Пример доступа к веб-хранилищу:

#### Доступ к локальному хранилищу (localStorage):

```javascript
// Сохраняем данные в localStorage
localStorage.setItem("username", "Alice");
localStorage.setItem("age", "25");

// Получаем данные из localStorage
const username = localStorage.getItem("username");
const age = localStorage.getItem("age");

console.log(username); // "Alice"
console.log(age); // "25"

// Удаляем данные из localStorage
localStorage.removeItem("username");
```

#### Доступ к сессионному хранилищу (sessionStorage):

```javascript
// Сохраняем данные в sessionStorage
sessionStorage.setItem("city", "New York");

// Получаем данные из sessionStorage
const city = sessionStorage.getItem("city");

console.log(city); // "New York"

// Удаляем данные из sessionStorage
sessionStorage.removeItem("city");
```

Для доступа к данным в веб-хранилище используется метод `getItem` для извлечения данных по ключу, метод `setItem` для сохранения данных, и метод `removeItem` для удаления данных. Данные сохраняются в виде пары ключ-значение.

Обратите внимание, что веб-хранилище доступно только на стороне клиента и может использоваться для хранения небольших объемов данных, таких как настройки пользователя, состояние приложения и другие важные данные.

## Какие методы доступны в сессионном хранилище (sessionStorage)?

В сессионном хранилище (sessionStorage) доступны следующие методы для работы с данными:

1. **`setItem(key, value)`**: Сохраняет пару ключ-значение в сессионном хранилище.

   ```javascript
   sessionStorage.setItem("username", "Alice");
   ```

2. **`getItem(key)`**: Извлекает значение по ключу из сессионного хранилища.

   ```javascript
   const username = sessionStorage.getItem("username");
   console.log(username); // "Alice"
   ```

3. **`removeItem(key)`**: Удаляет данные по указанному ключу из сессионного хранилища.

   ```javascript
   sessionStorage.removeItem("username");
   ```

4. **`clear()`**: Удаляет все данные из сессионного хранилища.

   ```javascript
   sessionStorage.clear();
   ```

Эти методы позволяют управлять данными в сессионном хранилище, добавлять новые данные, извлекать существующие значения, удалять данные и очищать всё хранилище. Обратите внимание, что данные, сохраненные в сессионном хранилище, будут доступны только в рамках текущей сессии браузера и будут удалены после закрытия вкладки или браузера.

## Что такое событие хранилища (storage event) и его обработчик событий в JavaScript?

Событие хранилища (storage event) - это событие, которое возникает, когда данные в веб-хранилище (`localStorage` или `sessionStorage`) изменяются в другой вкладке или окне браузера. С помощью этого события вы можете отслеживать изменения данных между разными сессиями в рамках одного домена.

### Пример использования события хранилища:

#### В первой вкладке:

```javascript
// Сохраняем данные в localStorage
localStorage.setItem("username", "Alice");
```

#### Во второй вкладке (или другом окне):

```javascript
// Слушаем событие хранилища
window.addEventListener("storage", (event) => {
  if (event.key === "username") {
    console.log(`Изменено имя пользователя на: ${event.newValue}`);
  }
});
```

В этом примере, при изменении имени пользователя в первой вкладке, событие хранилища срабатывает во второй вкладке (или другом окне). Обработчик события выводит новое значение имени пользователя.

### Обработчик события хранилища (storage event handler):

Обработчик события хранилища - это функция, которая будет выполнена при возникновении события хранилища. Он принимает объект события в качестве параметра, который содержит информацию о событии, включая измененный ключ (`event.key`), старое значение (`event.oldValue`), новое значение (`event.newValue`), домен и другие.

```javascript
// Обработчик события хранилища
function handleStorageChange(event) {
  console.log(`Ключ: ${event.key}`);
  console.log(`Старое значение: ${event.oldValue}`);
  console.log(`Новое значение: ${event.newValue}`);
}

// Добавляем обработчик события хранилища
window.addEventListener("storage", handleStorageChange);
```

Событие хранилища полезно, когда вам нужно отслеживать изменения данных между разными вкладками или окнами вашего веб-приложения.

## Зачем нужно веб-хранилище (web storage)?

Веб-хранилище (web storage) - это механизм, который позволяет веб-приложениям сохранять данные на стороне клиента, в браузере пользователя. Оно имеет несколько важных применений для улучшения пользовательского опыта и работы веб-приложений.

### Примеры применения веб-хранилища:

1. **Локальное сохранение данных**: Веб-хранилище позволяет приложениям сохранять данные, которые будут доступны даже после перезагрузки страницы или закрытия браузера. Это полезно для хранения настроек пользователя, последних действий или состояния приложения.

2. **Сессионное управление**: Веб-приложения могут использовать веб-хранилище для управления сессией пользователя. Это позволяет хранить информацию, которая будет доступна в течение текущей сессии, например, аутентификационные токены.

3. **Передача данных между страницами**: Веб-хранилище позволяет обмениваться данными между разными страницами одного домена. Это может быть полезно, если вы хотите передать какие-то данные с одной страницы на другую без использования сервера.

4. **Кэширование**: Веб-хранилище можно использовать для кэширования данных, чтобы уменьшить количество запросов к серверу и ускорить загрузку страниц.

5. **Отслеживание состояния приложения**: Веб-хранилище позволяет сохранять текущее состояние приложения, например, активную вкладку, выбранный раздел и другие параметры.

### Пример использования веб-хранилища:

Допустим, у вас есть веб-приложение для заметок. Вы хотите, чтобы пользователь мог вернуться к своим заметкам даже после перезагрузки страницы.

```javascript
// Сохраняем заметку в локальное хранилище
localStorage.setItem("note1", "Список покупок: молоко, яйца, хлеб");

// Извлекаем заметку из локального хранилища
const savedNote = localStorage.getItem("note1");
console.log(savedNote); // "Список покупок: молоко, яйца, хлеб"
```

В этом примере, заметка сохраняется в локальное хранилище и остается доступной даже после закрытия браузера или перезагрузки страницы.

В целом, веб-хранилище предоставляет удобный способ хранения данных на стороне клиента, улучшая пользовательский опыт и функциональность веб-приложений.

## Как проверить поддержку веб-хранилища браузером?

Для проверки поддержки веб-хранилища (web storage) в браузере можно использовать проверку наличия соответствующих объектов `localStorage` и `sessionStorage`.

### Пример проверки поддержки веб-хранилища:

```javascript
if (typeof Storage !== "undefined") {
  // Веб-хранилище поддерживается
  console.log("Веб-хранилище поддерживается в этом браузере.");
} else {
  // Веб-хранилище не поддерживается
  console.log("Веб-хранилище не поддерживается в этом браузере.");
}
```

Этот код проверяет, существует ли объект `Storage` (который используется для работы с веб-хранилищем) в глобальном контексте. Если поддержка есть, вы увидите сообщение о поддержке в консоли.

Обратите внимание, что веб-хранилище широко поддерживается современными браузерами, и большинство современных версий браузеров поддерживают эту функциональность. Вам, скорее всего, не понадобится часто проводить такую проверку.

## Как проверить поддержку веб-воркеров (web workers) в браузере?

Для проверки поддержки веб-воркеров (web workers) в браузере можно использовать проверку наличия объекта `Worker`.

### Пример проверки поддержки веб-воркеров:

```javascript
if (typeof Worker !== "undefined") {
  // Веб-воркеры поддерживаются
  console.log("Веб-воркеры поддерживаются в этом браузере.");
} else {
  // Веб-воркеры не поддерживаются
  console.log("Веб-воркеры не поддерживаются в этом браузере.");
}
```

Этот код проверяет, существует ли объект `Worker` (который используется для создания веб-воркеров) в глобальном контексте. Если поддержка есть, вы увидите сообщение о поддержке в консоли.

Веб-воркеры широко поддерживаются в современных браузерах, но стоит помнить, что некоторые устаревшие или очень старые браузеры могут не поддерживать эту функциональность. В большинстве случаев, однако, поддержка веб-воркеров не представляет проблемы.

## Приведите пример использования веб-воркера (web worker) в JavaScript

Веб-воркеры (web workers) - это фоновые потоки выполнения JavaScript, которые позволяют выполнять вычисления и задачи в отдельном потоке, не блокируя основной поток браузера. Они полезны для выполнения тяжелых вычислений и долгих операций, не влияя на отзывчивость пользовательского интерфейса.

### Пример веб-воркера:

```javascript
// Создаем файл worker.js

// worker.js
self.onmessage = function (event) {
  // Получаем данные из основного потока
  const data = event.data;

  // Выполняем вычисления (например, факториал)
  const result = calculateFactorial(data);

  // Отправляем результат обратно в основной поток
  postMessage(result);
};

function calculateFactorial(n) {
  if (n <= 1) {
    return 1;
  } else {
    return n * calculateFactorial(n - 1);
  }
}
```

В основном скрипте:

```javascript
// Создаем веб-воркера
const worker = new Worker("worker.js");

// Отправляем данные на обработку в веб-воркер
worker.postMessage(5);

// Получаем результат из веб-воркера
worker.onmessage = function (event) {
  const result = event.data;
  console.log(`Факториал: ${result}`);
};

// При необходимости завершаем работу веб-воркера
worker.terminate();
```

В этом примере мы создаем веб-воркера, который вычисляет факториал числа. Мы отправляем данные на обработку в веб-воркер, а затем получаем результат через событие `onmessage`. Обратите внимание, что веб-воркеры могут выполняться в отдельном файле (как `worker.js`) и не имеют доступа к DOM.

Веб-воркеры удобно использовать для выполнения вычислительно интенсивных операций, которые не должны блокировать основной поток браузера.

## Какие ограничения существуют у веб-воркеров по работе с DOM?

Веб-воркеры (web workers) предоставляют возможность выполнять код в отдельных фоновых потоках, что позволяет избежать блокировки основного потока браузера. Однако у веб-воркеров есть некоторые ограничения в отношении доступа и взаимодействия с DOM.

### Ограничения веб-воркеров по работе с DOM:

1. **Отсутствие доступа к DOM**: Веб-воркеры не имеют прямого доступа к DOM. Это означает, что они не могут взаимодействовать с элементами DOM, менять HTML-структуру или стили страницы.

2. **Отсутствие доступа к глобальным переменным**: Веб-воркеры не имеют доступа к глобальным переменным и функциям основного потока.

3. **Синхронизация и обмен данными**: Для обмена данными между веб-воркерами и основным потоком используются асинхронные механизмы, такие как события (`postMessage`). Это может привести к сложностям в синхронизации и обработке данных.

### Пример ограничений:

```javascript
// Веб-воркер
self.onmessage = function (event) {
  // Нельзя изменить DOM или получить доступ к window
  // Нельзя использовать глобальные переменные из основного потока
  // Это не сработает: document.getElementById("myElement").textContent = "Hello";

  // Можно только отправить сообщение обратно в основной поток
  postMessage("Hello from the worker!");
};
```

Поскольку веб-воркеры выполняются в отдельных потоках, они не могут напрямую влиять на пользовательский интерфейс и DOM. Однако они идеально подходят для вычислительно интенсивных операций и обработки данных, не связанных с изменением DOM.

## Что такое промис (Promise)?

Промис (Promise) - это объект в JavaScript, представляющий результат успешного завершения или ошибки асинхронной операции. Он позволяет более удобно и читаемо обрабатывать асинхронный код, делая его более структурированным и предсказуемым.

### Пример промиса:

```javascript
// Пример асинхронной функции, которая возвращает промис
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = "Данные получены";
      resolve(data); // Успешное завершение
      // Если произошла ошибка: reject(new Error("Ошибка получения данных"));
    }, 2000);
  });
}

// Использование промиса
fetchData()
  .then((result) => {
    console.log(result); // "Данные получены"
  })
  .catch((error) => {
    console.error(error);
  });
```

В этом примере функция `fetchData` возвращает промис, который успешно завершается через 2 секунды. Мы используем метод `.then` для обработки успешного выполнения промиса и метод `.catch` для обработки ошибки.

Промисы позволяют создавать цепочки асинхронных операций, улучшая читаемость и управляемость кода. Они также предоставляют механизмы для обработки нескольких асинхронных операций сразу, например, с помощью `Promise.all` или `Promise.race`.

## Зачем нужен промис (Promise)?

Промис (Promise) в JavaScript используется для более удобной и структурированной обработки асинхронного кода. Асинхронные операции, такие как запросы к серверу, чтение/запись в файлы или таймеры, могут занять некоторое время и могут быть завершены в будущем. Промисы помогают справиться с такими ситуациями и улучшить читаемость кода.

### Пример использования промиса:

```javascript
// Пример асинхронной функции с промисом
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = "Данные получены";
      resolve(data); // Успешное завершение
    }, 2000);
  });
}

// Использование промиса
fetchData()
  .then((result) => {
    console.log(result); // "Данные получены"
  })
  .catch((error) => {
    console.error(error);
  });
```

**Почему промисы полезны:**

1. **Обработка асинхронности**: Промисы предоставляют четкий способ обрабатывать асинхронные операции, позволяя избежать "callback hell" - глубоко вложенных коллбэков.

2. **Читаемость кода**: Код с использованием промисов более структурирован и легко читается, так как асинхронные операции описываются последовательно с помощью методов `.then` и `.catch`.

3. **Управление ошибками**: Промисы предоставляют механизм для обработки ошибок с помощью метода `.catch`, что делает код более надежным и предсказуемым.

4. **Цепочки операций**: Промисы позволяют создавать цепочки операций, где результат одной операции используется как вход для следующей.

5. **Параллельные операции**: Промисы также позволяют выполнять несколько асинхронных операций параллельно и ждать, пока все они завершатся.

Промисы стали стандартной практикой для обработки асинхронного кода и являются фундаментальным элементом при работе с современными веб-приложениями.

## Каковы три состояния промиса (Promise)?

Промис (Promise) в JavaScript имеет три основных состояния, которые описывают текущее состояние выполнения асинхронной операции.

1. **Ожидание (Pending)**: Начальное состояние, когда промис создан, но операция, связанная с ним, еще не завершена. Промис находится в ожидании результата.

2. **Выполнено (Fulfilled)**: Состояние, в котором асинхронная операция успешно завершена. Промис переходит в это состояние, когда вызывается функция `resolve()`, передавая ей результат операции.

3. **Отклонено (Rejected)**: Состояние, в котором асинхронная операция завершается с ошибкой. Промис переходит в это состояние, когда вызывается функция `reject()`, передавая ей информацию об ошибке.

### Пример использования состояний промиса:

```javascript
const promise = new Promise((resolve, reject) => {
  // Имитация асинхронной операции
  setTimeout(() => {
    const success = true;
    if (success) {
      resolve("Операция успешно выполнена");
    } else {
      reject(new Error("Произошла ошибка"));
    }
  }, 2000);
});

promise
  .then((result) => {
    console.log(result); // "Операция успешно выполнена"
  })
  .catch((error) => {
    console.error(error.message); // "Произошла ошибка"
  });
```

В этом примере промис переходит в состояние "Выполнено" (Fulfilled) при успешном завершении асинхронной операции, и в состояние "Отклонено" (Rejected) при ошибке. С помощью методов `.then` и `.catch` мы обрабатываем соответствующие состояния промиса.

## Что такое функция обратного вызова (callback function)?

Функция обратного вызова (callback function) в JavaScript - это функция, которая передается в качестве аргумента другой функции и вызывается после завершения определенной операции или события. Она позволяет создавать асинхронный код и контролировать его поток выполнения.

### Пример функции обратного вызова:

```javascript
// Пример асинхронной функции с функцией обратного вызова
function fetchData(callback) {
  setTimeout(() => {
    const data = "Данные получены";
    callback(data);
  }, 2000);
}

// Использование функции обратного вызова
fetchData((result) => {
  console.log(result); // "Данные получены"
});
```

В этом примере функция `fetchData` выполняет асинхронную операцию и после ее завершения вызывает переданную функцию обратного вызова. Таким образом, мы можем определить, что делать с данными после их получения.

Функции обратного вызова используются часто для обработки асинхронных операций, обработки событий, запросов к серверу и других сценариев, где результат операции может быть неизвестен на момент вызова функции. Однако, использование большого количества вложенных коллбэков может привести к "callback hell" - сложному для читаемости и поддержки коду.

## Зачем нужны функции обратного вызова (callback)?

Функции обратного вызова (callback) в JavaScript используются для управления асинхронным кодом и выполнения операций, которые зависят от завершения других операций. Они позволяют создавать гибкое и масштабируемое асинхронное программирование.

### Пример использования функций обратного вызова:

```javascript
// Пример асинхронной функции с функцией обратного вызова
function fetchData(callback) {
  setTimeout(() => {
    const data = "Данные получены";
    callback(data);
  }, 2000);
}

// Использование функции обратного вызова
fetchData((result) => {
  console.log(result); // "Данные получены"
});
```

**Почему функции обратного вызова полезны:**

1. **Асинхронность**: Функции обратного вызова позволяют обрабатывать асинхронные операции, такие как запросы к серверу, чтение файлов или таймеры, без блокировки основного потока выполнения.

2. **Управление потоком**: Функции обратного вызова позволяют контролировать порядок выполнения операций, например, вызывать вторую функцию только после завершения первой.

3. **События и обработчики**: Они также используются для обработки событий, например, обработки кликов, загрузки ресурсов или асинхронных запросов.

4. **Параметризация поведения**: Функции обратного вызова позволяют параметризовать, какой код должен быть выполнен после завершения операции. Это делает код более гибким и переиспользуемым.

5. **Избегание блокировок**: Они позволяют избежать блокировки пользовательского интерфейса, что делает приложение более отзывчивым.

Хотя функции обратного вызова очень полезны, при использовании большого количества вложенных коллбэков может возникнуть проблема "callback hell". Эту проблему можно решить с помощью промисов или асинхронных функций в более современных версиях JavaScript.

## Что такое "callback hell"?

"Callback hell" (иногда также называемое "преисполнение коллбэков") - это ситуация в асинхронном программировании, когда большое количество вложенных функций обратного вызова делает код сложным для чтения, поддержки и понимания. Такое состояние может возникнуть, когда асинхронные операции выполняются внутри других асинхронных операций, и код начинает сильно вклиниваться.

### Пример "callback hell":

```javascript
asyncOperation1(function (result1) {
  asyncOperation2(result1, function (result2) {
    asyncOperation3(result2, function (result3) {
      // И так далее...
    });
  });
});
```

В этом примере, каждая асинхронная операция выполняется внутри функции обратного вызова предыдущей операции. Это может привести к глубокому вложению и усложнению кода, а также усложнению обработки ошибок и отладки.

**Почему это проблема:**

1. **Читаемость**: Код становится трудночитаемым, сложно понять поток выполнения и логику операций.

2. **Обработка ошибок**: Обработка ошибок становится более сложной из-за множества точек неудачи.

3. **Поддержка и изменения**: Такой код сложно поддерживать и изменять, особенно когда требуется добавление или изменение функциональности.

### Как избежать "callback hell":

1. **Промисы**: Использование промисов позволяет создавать более структурированный код с использованием методов `.then` и `.catch`, избегая глубокой вложенности.

2. **Асинхронные функции**: В современных версиях JavaScript можно использовать ключевое слово `async` вместе с `await` для более линейного кода.

3. **Библиотеки**: Множество библиотек, таких как `async/await`, `Bluebird` и другие, предоставляют инструменты для более удобной работы с асинхронным кодом.

Соблюдение лучших практик и использование современных подходов помогут избежать "callback hell" и сделать код более читаемым и управляемым.

## Что такое события, отправляемые с сервера (Server-Sent Events)?

События, отправляемые с сервера (Server-Sent Events или SSE), представляют собой механизм веб-браузера для установления однонаправленного потока данных от сервера к клиенту по протоколу HTTP. Этот механизм позволяет серверу отправлять информацию клиенту без необходимости, чтобы клиент делал повторные запросы.

### Пример использования событий, отправляемых с сервера:

**Сервер (Node.js):**

```javascript
const http = require("http");

http
  .createServer((req, res) => {
    res.writeHead(200, {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    });

    setInterval(() => {
      res.write(`data: Сообщение с сервера\n\n`);
    }, 1000);
  })
  .listen(3000);
```

**Клиент (HTML/JavaScript):**

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Server-Sent Events Example</title>
  </head>
  <body>
    <div id="sse-data"></div>

    <script>
      const eventSource = new EventSource("/sse");

      eventSource.onmessage = (event) => {
        const sseDataElement = document.getElementById("sse-data");
        sseDataElement.innerHTML += `<p>${event.data}</p>`;
      };

      eventSource.onerror = (error) => {
        console.error("Error:", error);
      };
    </script>
  </body>
</html>
```

В этом примере сервер на Node.js отправляет события, содержащие текстовое сообщение, каждую секунду по пути `/sse`. Клиентский код создает экземпляр `EventSource` и слушает события, которые приходят с сервера. Полученные данные выводятся на страницу.

События, отправляемые с сервера, предоставляют простой и эффективный способ передачи данных от сервера к клиенту в режиме реального времени. Они особенно полезны для обновления информации на веб-странице без необходимости перезагрузки страницы или активных запросов от клиента.

## Как получать уведомления событий, отправляемых с сервера (Server-Sent Events)?

Для получения уведомлений о событиях, отправляемых с сервера (Server-Sent Events или SSE), в веб-браузере используется объект `EventSource`. Этот объект позволяет установить соединение с сервером и прослушивать события, приходящие с сервера в режиме реального времени.

### Пример получения уведомлений событий, отправляемых с сервера:

**Сервер (Node.js):**

```javascript
const http = require("http");

http
  .createServer((req, res) => {
    res.writeHead(200, {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    });

    setInterval(() => {
      res.write(`data: Сообщение с сервера\n\n`);
    }, 1000);
  })
  .listen(3000);
```

**Клиент (HTML/JavaScript):**

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Server-Sent Events Example</title>
  </head>
  <body>
    <div id="sse-data"></div>

    <script>
      const eventSource = new EventSource("/sse");

      eventSource.onmessage = (event) => {
        const sseDataElement = document.getElementById("sse-data");
        sseDataElement.innerHTML += `<p>${event.data}</p>`;
      };

      eventSource.onerror = (error) => {
        console.error("Ошибка:", error);
      };
    </script>
  </body>
</html>
```

В этом примере, когда сервер на Node.js отправляет события, клиентский код создает экземпляр `EventSource` и слушает события, которые приходят с сервера. Полученные данные выводятся на страницу. Каждую секунду сервер отправляет сообщение, и это сообщение отображается на веб-странице в реальном времени.

Использование объекта `EventSource` позволяет устанавливать длительное соединение с сервером и автоматически получать уведомления о событиях.

## Как проверить поддержку браузером событий, отправляемых с сервера (Server-Sent Events)?

Для проверки поддержки браузером событий, отправляемых с сервера (Server-Sent Events или SSE), вы можете использовать объект `EventSource` и проверить его наличие и функциональность.

### Пример проверки поддержки браузером событий, отправляемых с сервера:

```javascript
if (typeof EventSource !== "undefined") {
  // Браузер поддерживает SSE
  const eventSource = new EventSource("/sse");

  eventSource.onmessage = (event) => {
    console.log("Получено событие:", event.data);
  };

  eventSource.onerror = (error) => {
    console.error("Ошибка:", error);
  };
} else {
  // Браузер не поддерживает SSE
  console.error("Браузер не поддерживает Server-Sent Events.");
}
```

В этом примере мы проверяем, есть ли объект `EventSource` в глобальной области видимости. Если объект `EventSource` доступен, это указывает на поддержку SSE браузером, и мы можем создать соединение с сервером для получения событий. В противном случае, если объект `EventSource` не определен, браузер не поддерживает SSE.

Проверка поддержки SSE особенно важна, чтобы предоставить альтернативное поведение для браузеров, которые не поддерживают эту технологию.

## Какие события доступны для событий, отправляемых с сервера (Server-Sent Events)?

Для событий, отправляемых с сервера (Server-Sent Events или SSE), доступны следующие типы событий:

1. **`message`**: Это событие возникает, когда сервер отправляет новое событие. Вы можете использовать обработчик события `onmessage`, чтобы обрабатывать приходящие данные.

2. **`error`**: Это событие возникает, если происходит ошибка во время соединения или передачи данных. Вы можете использовать обработчик события `onerror`, чтобы обрабатывать ошибки.

3. **`open`**: Это событие возникает, когда соединение с сервером устанавливается. Однако, оно редко используется, так как события, отправляемые с сервера, подразумевают постоянное открытое соединение.

### Пример использования обработчиков событий:

```javascript
const eventSource = new EventSource("/sse");

eventSource.onmessage = (event) => {
  console.log("Получено событие:", event.data);
};

eventSource.onerror = (error) => {
  console.error("Ошибка:", error);
};
```

В этом примере мы устанавливаем обработчики для событий `message` и `error`. Когда на сервере отправляется новое событие, будет вызван обработчик `onmessage`, и мы выведем данные этого события в консоль. Если произойдет ошибка в соединении, будет вызван обработчик `onerror`, и мы выведем информацию об ошибке.
