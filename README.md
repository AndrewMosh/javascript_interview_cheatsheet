## Способы создания объекта

1. Литеральная нотация:

```
var obj = {}; // пустой объект
var person = {
  name: "John",
  age: 30,
  location: "New York"
};
```

2. Функция-конструктор:

```
function Person(name, age, location) {
  this.name = name;
  this.age = age;
  this.location = location;
}

var john = new Person("John", 30, "New York");
```

3. Object.create():

```
var personProto = {
  sayHello: function() {
    console.log("Hello!");
  }
};

var john = Object.create(personProto);
john.name = "John";
john.age = 30;
john.location = "New York";
```

4. Class (введена в ECMAScript 2015):

```
class Person {
  constructor(name, age, location) {
    this.name = name;
    this.age = age;
    this.location = location;
  }
}

var john = new Person("John", 30, "New York");
```

## Что такое цепочка прототипов

Прототипное наследование в JavaScript основано на концепции цепочки прототипов, или прототипной цепочки. Каждый объект в JavaScript имеет свойство прототипа (**proto**), которое ссылается на другой объект, называемый прототипом.

Если свойство не найдено в самом объекте, JavaScript будет искать его в прототипе, а затем в прототипе прототипа, и так далее, пока не будет найдено свойство или прототип станет равным null. Эта последовательность поиска свойств называется прототипной цепочкой.

Прототипное наследование позволяет объекту наследовать свойства своего прототипа. Если свойство не найдено в самом объекте, оно будет искаться в его прототипе и так далее. Это позволяет создавать иерархии объектов, где более специфичные объекты наследуют свойства от более общих объектов.

Например, если у объекта `obj` нет свойства `x`, JavaScript будет искать его в `obj.__proto__`, затем в `obj.__proto__.__proto__` и так далее, пока не будет найдено либо встретится null.

## Разница между `call`, `apply` и `bind`

В JavaScript, методы `call`, `apply` и `bind` используются для установки контекста выполнения функции и передачи аргументов.

Метод `call` вызывает функцию с заданным контекстом и передает аргументы в виде отдельных значений. Синтаксис: `function.call(context, arg1, arg2, ...)`.

Метод `apply` также вызывает функцию с заданным контекстом, но передает аргументы в виде массива. Синтаксис: `function.apply(context, [arg1, arg2, ...])`.

Метод `bind` создает новую функцию, привязывая ее к определенному контексту выполнения и, при необходимости, предоставляя некоторые аргументы. Этот метод не вызывает функцию немедленно, а возвращает новую функцию, которую можно вызвать позже. Синтаксис: `function.bind(context, arg1, arg2, ...)`. Вызов новой функции `bind` с переданными аргументами вызовет исходную функцию с указанным контекстом.

Основное отличие между `call`, `apply` и `bind` заключается в способе передачи аргументов. `call` передает аргументы в виде отдельных значений, `apply` передает аргументы в виде массива, а `bind` создает новую функцию с предустановленными аргументами.

## Что такое Json и основные операции с ним

JSON (JavaScript Object Notation) - это формат обмена данными, основанный на языке JavaScript. Он используется для передачи структурированных данных между клиентским и серверным приложениями. JSON представляет данные в удобном для чтения и записи формате и легко интерпретируется как людьми, так и компьютерами.

Основные операции, которые можно выполнять с JSON, включают следующее:

1. Создание JSON-объекта: Можно создавать JSON-объекты, используя фигурные скобки {}. Внутри объекта можно определить пары "ключ-значение".

2. Запись данных в JSON: Значения могут быть строками, числами, логическими значениями (true/false), null или другими JSON-объектами или массивами.

3. Чтение данных из JSON: Можно обратиться к значениям в JSON с помощью их ключей и получить доступ к содержимому.

4. Обновление данных в JSON: Можно обновлять значения, присваивая новые значения ключам.

5. Удаление данных из JSON: Ключи и их значения могут быть удалены из JSON-объекта.

6. Парсинг и сериализация: JSON может быть преобразован из строки в формате JSON в структуру данных и обратно с помощью парсинга и сериализации.

JSON является широко распространенным форматом данных, который часто используется в веб-разработке и API. Он легко читается компьютерами и людьми, и может быть использован практически на любом языке программирования.

## Для чего нужен метод slice

Метод `slice()` в JavaScript используется для создания нового массива, содержащего копию части исходного массива. Он позволяет выбирать элементы из исходного массива, начиная с указанного индекса и до определенного индекса (не включая его).

Синтаксис метода `slice()` выглядит следующим образом:

```javascript
array.slice(start, end);
```

Где:

- `start` - необязательный параметр, определяющий индекс, с которого начинается выбор элементов. Если `start` не указан, метод начинает выбор с индекса 0.
- `end` - необязательный параметр, указывающий индекс, до которого выбираются элементы. Метод выбирает элементы до этого индекса, но не включая его. Если `end` не указан, метод выбирает все элементы от `start` до конца массива.

Метод `slice()` возвращает новый массив, содержащий выбранные элементы. Исходный массив при этом не изменяется.

Пример использования метода `slice()`:

```javascript
let fruits = ["apple", "banana", "orange", "grapefruit", "kiwi"];

let citrus = fruits.slice(2, 4);
console.log(citrus); // ['orange', 'grapefruit']

let lastTwo = fruits.slice(-2);
console.log(lastTwo); // ['grapefruit', 'kiwi']

let copy = fruits.slice();
console.log(copy); // ['apple', 'banana', 'orange', 'grapefruit', 'kiwi']
```

В первом примере метод `slice(2, 4)` выбирает элементы с индексами 2 и 3 из массива `fruits` и возвращает новый массив `['orange', 'grapefruit']`.

Во втором примере метод `slice(-2)` выбирает последние два элемента из массива `fruits` и возвращает новый массив `['grapefruit', 'kiwi']`.

В последнем примере метод `slice()` без аргументов создает копию исходного массива `fruits` и возвращает новый массив `['apple', 'banana', 'orange', 'grapefruit', 'kiwi']`.

## Для чего нужен метод splice

Метод `splice()` в JavaScript используется для изменения содержимого массива путем удаления, замены или добавления элементов. Он может принимать несколько аргументов, включая индекс начала изменения, количество элементов для удаления и элементы, которые нужно добавить.

Например, если мы хотим удалить элементы из массива, мы можем использовать `splice()` следующим образом:

```javascript
const fruits = ["яблоко", "груша", "банан", "апельсин"];

// Удаляем один элемент начиная с индекса 1
fruits.splice(1, 1);
// Результат: ['яблоко', 'банан', 'апельсин']

// Удаляем два элемента начиная с индекса 0 и заменяем их другими элементами
fruits.splice(0, 2, "манго", "киви");
// Результат: ['манго', 'киви', 'банан', 'апельсин']
```

Таким образом, метод `splice()` позволяет нам гибко изменять содержимое массива, добавлять новые элементы и удалять существующие.

## Разница между `slice()` и `splice()`

Методы `slice()` и `splice()` в JavaScript имеют разные цели и функциональность.

Метод `slice()` используется для создания нового массива, который будет содержать выбранные элементы из исходного массива. Он принимает два аргумента: начальный индекс и конечный индекс (не включая сам элемент с указанным конечным индексом). `slice()` возвращает новый массив, содержащий выбранные элементы, исходный массив остается неизменным.

Пример использования `slice()`:

```javascript
const fruits = ["яблоко", "груша", "банан", "апельсин"];

const selectedFruits = fruits.slice(1, 3);
// Результат: ['груша', 'банан']
```

Метод `splice()`, напротив, изменяет исходный массив, позволяя удалять, заменять или добавлять элементы. Он принимает несколько аргументов, включая индекс начала изменений, количество элементов для удаления, а также элементы, которые нужно добавить в массив. `splice()` возвращает массив удаленных элементов или пустой массив (если ничего не было удалено).

Пример использования `splice()`:

```javascript
const fruits = ["яблоко", "груша", "банан", "апельсин"];

fruits.splice(1, 2);
// Результат: ['яблоко', 'апельсин']

fruits.splice(1, 0, "манго", "киви");
// Результат: ['яблоко', 'манго', 'киви', 'апельсин']
```

Таким образом, основное отличие между `slice()` и `splice()` заключается в том, что `slice()` создает новый массив, содержащий выбранные элементы, не изменяя исходный массив, а `splice()` изменяет исходный массив путем удаления, замены или добавления элементов.

## Как сравнить Object и Map

Объекты (Objects) и карты (Maps) являются структурами данных в JavaScript и используются для хранения пар ключ-значение. Однако у них есть некоторые различия в функциональности и использовании.

Объекты в JavaScript являются коллекциями свойств, где каждое свойство имеет имя (ключ) и соответствующее значение. Ключи в объектах являются строками или символами. Объекты поддерживают доступ к значениям по ключу, добавление и удаление свойств, итерацию по свойствам и прочие операции. Однако у объектов также есть прототипы и методы, которые позволяют наследовать и расширять свойства и функциональность объектов.

Map, с другой стороны, является коллекцией, где значения хранятся в виде пар ключ-значение. Ключи в Map могут быть любого типа данных, включая объекты и функции. Map поддерживает операции добавления, удаления и обновления пар ключ-значение, а также получение значения по ключу. Он также предоставляет методы для итерации по парам ключ-значение и общую информацию о размере коллекции.

Основная разница между объектами и картами заключается в том, что объекты лучше подходят для создания и управления свойствами с определенной структурой, тогда как карты обеспечивают более гибкую структуру данных и позволяют использовать любой тип данных в качестве ключа. Кроме того, карты имеют лучшую производительность в случаях, когда требуется частое добавление и удаление пар ключ-значение.

## Разница между операторами '==' и '==='

Оператор "==" используется для сравнения значений двух операндов и возвращает true, если значения равны. Однако, при использовании оператора "==" не происходит проверка на тип данных операндов.

Оператор "===" (тройное равенство) используется для строгого сравнения значений и типов данных двух операндов. Он возвращает true, только если значения и типы данных операндов полностью совпадают.

Например:

1 == "1" возвращает true, так как значения равны, несмотря на разные типы данных (число и строка).

1 === "1" возвращает false, так как значения отличаются и типы данных тоже отличны (число и строка).

## Лямбда функции и стрелочные функции

Лямбда-функции или стрелочные функции в JavaScript представляют собой сокращенный синтаксис для создания функций. Они были добавлены в стандарт ECMAScript 6 (ES6) и позволяют определить функции более компактно и кратко.

Синтаксис лямбда-функции выглядит следующим образом:

(parameter1, parameter2, ..., parameterN) => {
// код функции
}

Этот синтаксис позволяет передавать параметры функции в скобках и описывать тело функции после стрелки (=>). Если тело функции состоит из единственного выражения, то оно может быть написано без фигурных скобок. В этом случае значение этого выражения автоматически станет возвращаемым значением функции.

Примеры использования лямбда-функций:

// Обычная функция
function multiply(a, b) {
return a \* b;
}

// Лямбда-функция
const multiply = (a, b) => a \* b;

// Вызов функции
console.log(multiply(2, 3)); // Выведет 6

Лямбда-функции очень удобны в тех случаях, когда требуется использовать функции как аргументы в других функциях (например, методы массивов, такие как map, filter, reduce и т.д.), либо для определения кратких, однострочных функций.
